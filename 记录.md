### 1003 Emergency

题目大意：n个城市m条路，每个城市有救援小组(即点权)，所有的边的边权已知。给定起点和终点，求从起点到终点的最短路径条数以及最短路径上的救援小组数目之和。如果有多条就输出点权（城市救援小组数目）最大的那个

解题思路：用Dijkstra算法，求出从起始点出发到各个节点的最短路径长度、最短路径条数、最大路过的点权之和；涉及到三个与目的相关的需要不断更新的数组，dis[i]表示从出发点到i结点最短路径的路径长度，num[i]表示从出发点到i结点最短路径的条数，w[i]表示从出发点到i点救援队的数目之和；

核心代码

```C++
int n, m, c1, c2;
int e[510][510], weight[510], dis[510], num[510], w[510];
bool visit[510];
const int inf = 99999999;
int main() {
	scanf("%d %d %d %d", &n, &m, &c1, &c2);
	for (int i = 0; i < n; i++) scanf("%d", &weight[i]);
	fill(e[0], e[0] + 510 * 510, inf);
	fill(dis, dis + 510, inf);
	int a, b, c;
	for (int i = 0; i < m; i++) {
		scanf("%d %d %d", &a, &b, &c);
		e[a][b] = e[b][a] = c;
	}
	dis[c1] = 0;  // dis[i]表示从出发点到i节点最短路径的路径长度
	w[c1] = weight[c1];  // w[i]表示从出发点到i节点，点权之和
	num[c1] = 1;  // num[i]表示从出发点到i节点最短路径的条数
	for (int i = 0; i < n; i++) {
		int u = -1, minn = inf;
		for (int j = 0; j < n; j++) {  // 这个for的目的是在每一i下，选出一个节点u，去更新与u相邻的那些邻居节点v距离起始节点的长度
			if (visit[j] == false && dis[j] < minn) {
				u = j;
				minn = dis[j];  // 找出从出发点到节点j的最短路径，记下其长度
			}
		}
		if (u == -1) break;
		visit[u] = true;  // 每轮i，只将一个节点的访问状态置为“已访问”
		for (int v = 0; v < n; v++) {
			if (visit[v] == false && e[u][v] != inf) {  // v节点未被访问过且可达
				if (dis[u] + e[u][v] < dis[v]) {  // 如果新的路径更短，则更新
					dis[v] = dis[u] + e[u][v];  // 更新最短路径长度
					num[v] = num[u];  // 更新最短路径的条数
					w[v] = w[u] + weight[v];  // 更新最短路径路过的点权之和
				}
				else if (dis[u] + e[u][v] == dis[v]) {
					num[v] = num[v] + num[u];  // 若有多条路径，增加最短路径的条数
					if (w[u] + weight[v] > w[v]) {  // 若有多条最短路径，找点权之和最大
						w[v] = w[u] + weight[v];
					}
				}
			}
		}
	}  // 至此，已经找到了从c1出发到各个节点的最短路径长度、最短路径条数、最大路过的点权之和
	printf("%d %d", num[c2], w[c2]);  // 输出需要的c2终点
	return 0;
}
```

**可以学习的**

1、Dijkstra算法的基本思想：固定了一个顶点作为源结点然后找到该顶点到图中所有其它结点的最短路径，产生一个最短路径树。本算法每次取出未访问结点中距离最小的，用该结点更新其他结点的距离。

2、Dijkstra算法的扩展，在计算最短路径时，也可以同时计算最短路径条数、最短路径路过的点权重之和

### 1004 Counting Leaves

题目大意：给定一棵树，给的形式是：告知节点总数N、非叶子节点数量M；M行中每一行，告知非叶子节点的编号、其儿子的数量以及儿子的编号。目的是求出树的每个高度中叶子节点的数量。

解题思路：**用dfs，用二维数组保存每一个有孩子结点的结点以及他们的孩子结点，从根结点开始遍历，直到遇到叶子结点，就将当前层数depth的book[depth]++；标记第depth层拥有的叶子结点数，最后输出**

核心代码

```C++
vector<int> v[100];  // 容器v存储树
int book[100], maxdepth = -1;  // book存答案，即每一层叶子节点的数量

void dfs(int index, int depth) {
    if (v[index].size() == 0) {  // 若当前节点没有孩子，则当前层叶子节点数量加1
        book[depth]++;
        maxdepth = max(maxdepth, depth);
        return;
    }
    // 若当前节点有孩子，则遍历其孩子节点
    for (int i = 0; i < v[index].size(); i++) {
        dfs(v[index][i], depth + 1);
    }
}
```

**可以学习的**

1、邻接链表存二维数组可节省空间；

2、使用dfs的基本思想，对树进行操作

### 1005 Spell It Right

题目大意：给一个非负整数N，N可以很大，$10^{100}$。目的是计算N的每个数字的和，并使用英文输出和的每个数字。

解题思路：使用string存储N，利用（a[i] - '0'）计算每一位的和sum；将sum转化为string；输出。

**可以学习的**

1、string的使用，常用函数to_string()，记得包括头文件；

2、char减'0'得到整型数的操作

### 1006 Sign In and Sign Out

题目大意：给出n个人的id、签到时间、签出时间，目的是求最早签到的人的ID和最晚签出的人的ID。

解题思路：将时间都转化为以秒数，ID存入string，最早和最晚的时间分别保存在变量minn和maxn中，并同时更新当前最早和最晚的人的ID；输出。

**可以学习的**

1、格式化输入时，如时间，使用scanf是非常好的选择；

2、最大最小值的初始化，可以使用INT32_MIN、INT32_MAX

### 1007 Maximum Subsequence Sum

题目大意： 给出一个长度为n的整数序列，目的是求最大连续子序列和，输出最大的和以及这个子序列的开始值和结束值。如果所有数都小于0，那么认为最大的和为0，并且输出首尾元素。

解题思路：设，sum为要求的最大和，temp为临时最大和，leftindex和rightindex为所求的子序列的开始和结束的下标，tempindex为标记left的临时下标。

让temp = temp + v[i] ，判断，当temp比sum大，就更新sum的值、leftindex的值、rightindex的值；当temp < 0，那么后面不管来什么值，都应该舍弃temp < 0前面的内容，因为负数只可能拉低总和，不可能增加总和，所以直接舍弃。

舍弃后，令temp=0，重新开始算总和，并且同时更新left的临时值tempindex为i+1，即下一个位置的下标。

因为对于所有值都为负数的情况要输出0、第一个值、最后一个值，所以在输入（遍历）的时候用flag判断是不是所有的数字都小于0，如果是，则需要在输出时作特殊处理。这里没有用flag，取而代之的是为leftindex和rightindex赋初值时，直接赋为0和n-1，这样若temp一直小于0，leftindex和rightindex不会更新，输出时也是正确的。

核心代码

```C++
int main() {
	int n;
	scanf("%d", &n);
	vector<int> v(n);
	int leftindex = 0, rightindex = n - 1, sum = -1, temp = 0, tempindex = 0;
	for (int i = 0; i < n; i++) {
		scanf("%d", &v[i]);  // 边输入，边操作，O(n)的复杂度
		temp = temp + v[i];  // 临时的子序列总和
		if (temp < 0) {  // 若当前总和小于0，使总和重新为0，下标为下一个位置
			temp = 0;
			tempindex = i + 1;
		}
		else if (temp > sum) {  // 若当前总和变大了，则更新最大总和、左右下标
			sum = temp;
			leftindex = tempindex;
			rightindex = i;
		}
	}
	if (sum < 0) sum = 0;
	printf("%d %d %d", sum, v[leftindex], v[rightindex]);
	return 0;
}
```

**可以学习的**

1、最长子序列和的写法

2、当算法时间复杂度是O(n)，且一组输入有n个数时，可以边输入，边操作

### 1008 Elevator

题目大意：电梯初始停在0层，告知上一层需6s，下一层需4s，停一次需5s。现给出一个电梯停的序列，目的是求出走完所有给出楼层需要多少时间。

解题思路：累计计算，输出。

**可以学习的**

1、当算法时间复杂度是O(n)，且一组输入有n个数时，可以边输入，边操作

### 1009 Product of Polynomials

题目大意：求两个多项式的乘积

解题思路：float类型的arr数组保存第一组多项式，ans数组保存答案，以幂次为数组下标存储；输入第二组多项式时，一边输入，一边直接计算结果，存入ans数组。最后按幂次从高到低输出。

核心代码

```C++
int main() {
	int n1, n2, a, cnt = 0;
	float b, arr[1001] = { 0.0 }, ans[2001] = { 0.0 };
	scanf("%d", &n1);
	for (int i = 0; i < n1; i++) {
		scanf("%d %f", &a, &b);
		arr[a] = b;
	}
	scanf("%d", &n2);
	for (int i = 0; i < n2; i++) {
		scanf("%d %f", &a, &b);
		for (int j = 0; j < 1001; j++) {
			ans[j + a] += arr[j] * b;  // 相乘得到的项次数更高，故+a
		}
	}
	for (int i = 2000; i >= 0; i--) {
		if (ans[i] != 0.0) cnt++;
	}
	cout << cnt;
	for (int i = 2000; i >= 0; i--) {
		if (ans[i] != 0.0) {
			// cout << " " << i << " " << fixed << setprecision(1) << ans[i];
			printf(" %d %.1f", i, ans[i]);
		}
	}
	return 0;
}
```

**可以学习的**

1、使用 printf 或 cout 进行格式化输出；

2、与多项式相关的题，如多项式相加、多项式相乘，以幂次为数组下标存储是一个非常不错的方式

### 1010 Radix

题目大意：给出两个长度不超过10的字符串，告知其中一个是几进制。目的是求另一个数会在几进制下与这个数相等，输出进制数即可；若不存在可能相等，则输出Impossible。

解题思路：先将知道是几进制的数转化为10进制下的数值，存储在long long中；然后用二分查找遍历进制数，并将另一个数也转化为10进制，对比都在10进制下的两个数，直到二者相等或找不到；输出。

核心代码

```C++
long long convert(string n, long long radix) { // 将数值n按照radix进制转化为10进制表示的数
	long long sum = 0;  // 由于返回值是long long，当radix较大时容易溢出，变成负数
	int temp = 0;
	for (int i = 0; i < n.length(); i++) {
		temp = isdigit(n[i]) ? n[i] - '0' : n[i] - 'a' + 10;  // 分两段考虑字符转数值
		sum += temp * pow(radix, n.length() - i - 1);
	}
	/*
	int index = 0;  // 使用string中的rbegin()和rend()函数来反向遍历字符串
	for (auto it = n.rbegin(); it != n.rend(); it++){
		temp = isdigit(*it) ? *it - '0' : *it - 'a' + 10;
		sum += temp * pow(radix, index++);
	}
	*/
	return sum;
}
long long find_radix(string n, long long num) { // 找到令两个数值相等的进制数
	char it = *max_element(n.begin(), n.end());
	long long low = (isdigit(it) ? it - '0' : it - 'a' + 10) + 1;
	long long high = max(low, num);  // low有可能大于num，例如n为0，num为0
	while (low <= high) {
		long long mid = (low + high) / 2;  // 二分查找
		long long t = convert(n, mid);
		if (t < 0 || t > num) { // 将n转换为十进制数时，由于num可以较大(10^18),convert后long long可能会溢出，变成负数
			high = mid - 1;
		}
		else if (t == num) return mid;
		else low = mid + 1;
	}
	return -1;
}
```

**可以学习的**

1、使用二分查找加快遍历速度，其写法；

2、使用string中的rbegin()和rend()函数来反向遍历字符串；

3、在合适的时候使用三目运算符，有助于精简代码

### 1011 World Cup Betting

题目大意：赌球，给出三场比赛赢、平、输的赔率，选取每场比赛中赔率最大的数以及对应的赢、平、输结果；按照公式计算出利润；输出

解题思路：依次读入每场比赛赢、平、输的赔率，求最大值及其下标，输出下标，ans累乘；按照公式求出利润值；输出

**可以学习的**

1、最普通的求最大值及其下标的写法

### 1012 The Best Rank

题目大意：给出n个学生的3门成绩，平均分可自己算；那么每个学生有4个排名；现有m个学生来查询自己的最好排名以及是哪个科目最好，若4个名次中的某些相同，则按A>C>M>E的优先级输出；若查询的学生id不存在，则输出N/A

解题思路：使用结构体stu存储学生的id、四门成绩、四门排名、最好排名对应的科目下标；

处理同分数情况的方式，采用1、1、3、4的方式，而不是1、1、2、3；

从示例中看，平均分是四舍五入得出的，故求平均分时，需+0.5再取整；

存储四门成绩时，考虑到优先级是A>C>M>E，故按照这个顺序存储，按照这个顺序排序，可以简化逻辑；

处理查询时学生是否存在的问题，定义exist数组，以id为其下标，为0就说明不存在某学生，不为0还可以映射为stu的下标，一举两得。

核心代码

```C++
struct node {
	int id, best;  // best存rank最小的下标
	int score[4], rank[4];
}stu[2001];

int exist[1000000] = { 0 }, flag = -1;
bool cmp1(node a, node b) return a.score[flag] > b.score[flag];
int main() {
	int n, m, id;
	cin >> n >> m;
	for (int i = 0; i < n; i++) {
		scanf("%d %d %d %d", &stu[i].id, &stu[i].score[1], &stu[i].score[2], &stu[i].score[3]);
		stu[i].score[0] = (stu[i].score[1] + stu[i].score[2] + stu[i].score[3]) / 3.0 + 0.5;
	}
	for (flag = 0; flag <= 3; flag++) {
		sort(stu, stu + n, cmp1);  // 从大到小排，并且通过flag循环将A、C、M、E均排序
		stu[0].rank[flag] = 1;
		for (int i = 1; i < n; i++) {  // 求出名次rank
			stu[i].rank[flag] = i + 1;
			if (stu[i].score[flag] == stu[i - 1].score[flag]) {  // 如果同分
				stu[i].rank[flag] = stu[i - 1].rank[flag];  // 同分则rank取相同，取最靠前那个
			}
		}
	}
	for (int i = 0; i < n; i++) {
		exist[stu[i].id] = i + 1;  // 在sort之后再给exist赋值，才能以其值作下标访问stu
		stu[i].best = 0;
		int minn = stu[i].rank[0]; // 求出每个学生的最佳rank，即求最小值
		for (int j = 1; j <= 3; j++) {
			if (stu[i].rank[j] < minn) {
				minn = stu[i].rank[j];
				stu[i].best = j;
			}
		}
	}
	char c[5] = { "ACME" };
	for (int i = 0; i < m; i++) {
		cin >> id;
		int temp = exist[id]; // 以id为下标，构造出了一一映射的关系
		if (temp) {
			int best = stu[temp - 1].best;
			printf("%d %c\n", stu[temp - 1].rank[best], c[best]);
		}
		else printf("N/A\n");
	}
	return 0;
}
```

**可以学习的**

1、结构体的使用，对结构体sort需要自己构造cmp函数；

2、四舍五入的方式，即+0.5再取整；

3、涉及到查询id是否存在的问题时，定义一个以id为下标、index为值的exist数组，是不错的方案；

4、若存储几个同等地位的数时，题目有给某种优先级顺序，那么按照这个顺序来存是值得考虑的方式

### 1013 Battle Over Cities

题目大意：给出n个城市之间有相互连接的m条道路，当删除其中的一个城市及与其连接的道路时，求出需要另外添加至少多少条路线才能让剩余的所有城市重新连通

解题思路：将问题抽象出来，求添加最少的道路数，就是连通分量数减去1，因为当a个互相分立的连通分量需要变为连通图的时候，只需要添加a-1条道路，就能让他们相连。所以这道题就是求：去除了某个结点之后其他的图所拥有的连通分量数

核心代码

```C++
int v[1001][1001], n;
bool visit[1001];
void dfs(int node) {
	visit[node] = true;  // 将访问过的节点置为true
	for (int i = 1; i <= n; i++)  // 遍历所有节点找强连通图，只能这么做？恐怕是的
		if (visit[i] == false && v[node][i] == 1)  // 若当前节点还未被访问，且i节点与当前节点是相邻的
			dfs(i);  // 说明i节点与当前节点是连通的，则深度搜索i节点
}
int main() {
	int m, k, a, b;
	cin >> n >> m >> k;
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		v[a][b] = v[b][a] = 1;  // 邻接矩阵存图的连接关系
	}
	for (int i = 0; i < k; i++) {
		cin >> a;
		fill(visit, visit + 1001, false);  // 每做一个节点的强连通分量，需要重置整张图为未访问状态
		int cnt = 0;
		visit[a] = true;  // 被去掉的节点，只需将其的访问状态置为“已访问”即可
		for (int j = 1; j <= n; j++) {
			if (visit[j] == false) {
				dfs(j);  // 这里的一个dfs就可以将一张强连通分量图置为“已访问”状态
				cnt++;  // 强连通分量的个数加一
			}
		}
		cout << cnt - 1 << endl;  // 强连通分量的个数 - 1就是需要增加的边的条数，因为一个强连通分量就代表着一张独立的图
	}
	return 0;
}
```

**可以学习的**

1、遍历图的方法，设置visit数组，记录图中节点的访问状态，dfs去遍历；

2、fill函数，用来填充容器

### 1014 Waiting in Line

题目大意：有n个窗口，每个窗口最多可以排队m人，多余的人在黄线外，不参与排队；现有k位客户需要服务，给出每位客户办业务的所需时间，单位为分钟；银行早上8点开始提供服务，客户会优先选择队伍短的进行排队，若有2支或以上的队伍长度相同，则客户选择窗口数最小的；现有q位用户在等待，包括黄线内和黄线外，目的是求出这q位用户服务结束的时间，格式为HH:MM；若在17:00后仍没有得到服务，则银行关门，输出sorry。

解题思路：设立结构体，poptime代表队首的人出队的时间，endtime代表队尾的人出队的时间。poptime是为了让黄线外的人可以计算出哪一个队列先空出人来（poptime最小的那个先有人服务完毕），endtime是为了入队后加上自己本身的服务所需时间可以计算出自己多久才能被服务完毕。且前一个人的endtime可以得知自己是不是需要被Sorry（如果前一个人服务结束时间超过17:00，自己当前入队的人就是sorry）。还有一个queue表示所有当前该窗口的排队队列。
对于前m\*n个人，也就是排的下的情况下，所有人依次到窗口前面排队。对于m\*n之后的人，当前人选择poptime最短的入队，让队伍的第一个人出列），如果前面一个人导致的endtime超过17点就标记自己的sorry为true。

计算时间的时候按照分钟计算，最后再考虑08点开始和转换为小时分钟的形式会比较简便

核心代码

```C++
struct node {
	int poptime, endtime;  // poptime代表队首的人出队的时间，endtime代表队尾的人出队的时间
	queue<int> q;  // 表示当前窗口的排队队列
};
int main() {
	int n, m, k, q, index = 1;  // index是遍历k个客户服务时间用的，贯穿全文
	scanf("%d %d %d %d", &n, &m, &k, &q);
	vector<int> time(k + 1), result(k + 1);  // 数组不能用变量k声明，而vector可以
	for (int i = 1; i <= k; i++) scanf("%d", &time[i]);
	vector<node> window(n + 1); // 为每个窗口都维持一个队列
	vector<bool> sorry(k + 1, false);  // 
	for (int i = 1; i <= m; i++) {  // 遍历窗口队列容量，即再装第二排，
		for (int j = 1; j <= n; j++) {  // 遍历窗口，即先装第一排，
			if (index <= k) {  // 用于截断k<n*m的情况，k>n*m时，这个if会一直成立
				window[j].q.push(time[index]);  // 初始化，将客户一个个装进队列里
				if (window[j].endtime >= (17 - 8) * 60) 
					sorry[index] = true;  // 若当前该队列队尾出队的时刻超过了17点，则新入队的人只能sorry
				window[j].endtime += time[index];  // 每入队一个人就要更新当前队列的endtime
				if (i == 1) window[j].poptime = window[j].endtime;
				result[index] = window[j].endtime;
				index++;
			}
		}
	}  // 至此，初始化完成，即将黄线内的人塞满了
	while (index <= k) {  // 若黄线外没人，则这个while就不用进去
		int tempmin = window[1].poptime, tempwindow = 1;
		for (int i = 2; i <= n; i++) 
			if (window[i].poptime < tempmin) {  // 找队首最快结束服务的各窗口
				tempmin = window[i].poptime;
				tempwindow = i;
			}
		window[tempwindow].q.pop();  // 找到最快结束服务的客户后，让他出队
		window[tempwindow].q.push(time[index]);  // 出队后，让黄线外的下一个客户进入这个队列
		window[tempwindow].poptime += window[tempwindow].q.front();
		if (window[tempwindow].endtime >= (17 - 8) * 60) sorry[index] = true;
		window[tempwindow].endtime += time[index];
		result[index] = window[tempwindow].endtime;
		index++;
	}  // 至此，完成k个客户的服务
	for (int i = 1; i <= q; i++) {
		int query, minute;
		scanf("%d", &query);
		minute = result[query];
		if (sorry[query] == true) printf("Sorry\n");
		else printf("%02d:%02d\n", minute / 60 + 8, minute % 60);
	}
	return 0;
}
```

**可以学习的**

1、队列的使用；pop()、push()、front()等函数的使用；

2、输出HH:MM的格式，使用printf较为简便；

3、用结构体将容器和常规变量组合在一起，用得好可以很强

### 1015 Reversible Primes

题目大意：给出规则如下，如果一个数本身是素数，而且在radix进制下反转后的树数在十进制下也是素数，就输出Yes，否则就输出No

解题思路：先判断输入n是否为素数，若是，把n转化为radix进制再反过来转换为10进制，判断其是否为素数

核心代码

```C++
bool isprime(int n) {
	if (n <= 1) return false;
	int sqr = int(sqrt(n * 1.0));
	for (int i = 2; i <= sqr; i++) if (n % i == 0) return false;
	return true;
}
int main() {
	int n, radix;
	while (scanf("%d", &n) != EOF) {  // 处理不给数据组数的输入
		if (n < 0) break;
		scanf("%d", &radix);
		if (isprime(n) == false) {
			printf("No\n");
			continue;
		}
		int len = 0, arr[100];
		do {  // 将数值逐位提取到数组中存储，下标小的是低位，长度为len
			arr[len++] = n % radix;
			n = n / radix;
		} while (n != 0);
		for (int i = 0; i < len; i++) 
			n = n * radix + arr[i];  // 将逐位存储的radix进制的数转化为十进制
		printf("%s", isprime(n) ? "Yes\n" : "No\n");
	}
	return 0;
}
```

**可以学习的**

1、素数判断函数，isprime的写法；

2、将数值逐位提取到数组中存储，以及将逐位存储的radix进制的数转化为十进制，的写法

### 1016 Phone Bills

题目大意：给出一天24小时每个小时的电话费价格，单位0.01$；再给出n行打电话的记录，包括人名、时间MM:dd:HH:mm、on-line/off-line；目的是打印出每个人的电话账单，包括人名、月份、电话开始时间、电话结束时间、持续时间、电话费用；输出时，按照人名字母序，再按时间先后顺序

解题思路：使用结构体存储每一行电话记录；将给出的数据先按照人名字母序排序，再按照时间的先后顺序排列，这样遍历时前后两个名字相同且状态依次为on-line、off-line的就是合格数据；排序后，声明map，将配对好的电话记录按照姓名转存到map中；按格式输出

```C++
struct node {
	string name;
	int month, day, hour, minute, status, time;  // time是换算到0:00:00的分钟数量，比大小用的
};
bool cmp1(node a, node b) return a.name != b.name ? a.name < b.name : a.time < b.time;
double billFromZero(node call, int* rate) {  // 从现在算到0:00:00的电话费用
	double total = rate[call.hour] * call.minute + rate[24] * 60 * call.day;
	for (int i = 0; i < call.hour; i++) total += rate[i] * 60;
	return total / 100.0;
}

int main() {
	int rate[25] = { 0 }, n;
	for (int i = 0; i < 24; i++) {
		cin >> rate[i];
		rate[24] += rate[i];  // 打一整天电话的费率
	}
	cin >> n;
	vector<node> data(n);  // n条call record
	for (int i = 0; i < n; i++) {
		cin >> data[i].name;
		scanf("%d:%d:%d:%d", &data[i].month, &data[i].day, &data[i].hour, &data[i].minute);
		string temp;
		cin >> temp;
		data[i].status = (temp == "on-line") ? 1 : 0;
		data[i].time = data[i].day * 24 * 60 + data[i].hour * 60 + data[i].minute;  // 以当月起点为基准，计算距基准的时间
	}  // 至此，输入完成
	// 将n个call record先按照姓名排序，再按照时间排序，这样遍历时前后两个名字相同且状态依次为1、0的就是合格数据
	sort(data.begin(), data.end(), cmp1);
	map<string, vector<node>> custom;
	for (int i = 1; i < n; i++) {
		if (data[i].name == data[i - 1].name && data[i - 1].status == 1 && data[i].status == 0) {  // 若配对成功
			custom[data[i - 1].name].push_back(data[i - 1]);
			custom[data[i].name].push_back(data[i]);  // 则将这一通电话的2个记录按照人名放到map中
		}
	}  // 至此，配对完成，可以进行输出了
	for (auto it : custom) {  // 遍历map
		vector<node> temp = it.second;  // 对一个人进行输出
		cout << it.first;
		printf(" %02d\n", temp[0].month);
		double total = 0.0;
		for (int i = 1; i < temp.size(); i += 2) {  // 一对一对输出
			double t = billFromZero(temp[i], rate) - billFromZero(temp[i - 1], rate);
			printf("%02d:%02d:%02d %02d:%02d:%02d %d $%.2lf\n", temp[i - 1].day, temp[i - 1].hour, temp[i - 1].minute, temp[i].day, temp[i].hour, temp[i].minute, temp[i].time - temp[i - 1].time, t);
			total += t;
		}
		printf("Total amount: $%.2lf\n", total);
	}
	return 0;
}
```

**可以学习的**

1、map的使用，遍历map的方法，用.first和.second访问map的元素

2、计算较为复杂的时间时，比如MM:dd:HH:mm，找一个基准点，比如当月1号，换算为其距基准的时间

3、结构体的使用，便利

### 1017 Queueing at Bank

题目大意：有n个人来银行，银行有k个窗口，给出每个人的到达时间和所需的服务时间，目的是求出所有人的平均等待时间；由于银行的工作时间是8:00到17:00，早于8:00得等，晚于17:00不提供服务也就不参与平均值的计算

解题思路：使用结构体存储客户到达的时间come和所需的服务时间time；输入时可以先把hh:mm:ss格式的时间转换为以当天0点为基准的秒数，且晚于17:00到的客户直接忽略掉；这里排队的机制决定了我们可以按照到达时间对客户进行排序，后面就客户就可以按照这个顺序去办理业务；使用一个长度为窗口长度的优先队列维护窗口办理完业务的时刻，若最早结束服务的窗口时间早于客户的到达时间，则下一位客户不需要等待，直接将这位客户办理完业务的时间入队列；若最早结束服务的窗口时间晚于客户的到达时间，则下一位客户需要等待，等待的时间是二者相减

核心代码

```C++
const int maxn = 10005;
struct node {
	int come, time;  // come是到银行的时间，time是所需的服务时间
} p[maxn];
int cmp(node n1, node n2) { return n1.come < n2.come;  // 先来的先服务 }
int n, k, cnt = 0, total = 0;
int main() {
	cin >> n >> k;
	for (int i = 0; i < n; i++) {
		int hh, mm, ss, tt;
		scanf("%02d:%02d:%02d %d", &hh, &mm, &ss, &tt);
		int sum = hh * 3600 + mm * 60 + ss;  // 将hh:mm:ss格式的时间转换为以当天0点为基准的秒数
		if (sum > 17 * 3600) continue;  // 晚于17:00来的人直接忽视
		p[++cnt].time = tt * 60;
		p[cnt].come = sum;
	}
	sort(p + 1, p + 1 + cnt, cmp);  // 按照到达的先后顺序排序
	priority_queue<int, vector<int>, greater<int>> q;  // 优先队列，升序
	for (int i = 1; i <= k; i++) q.push(8 * 3600);  // 初始化这个长度为窗口数量k的优先队列
	for (int i = 1; i <= cnt; i++) {
		if (q.top() <= p[i].come) {  // 不需要等
			q.push(p[i].come + p[i].time);  
			q.pop();
		} else {  // 等待一段时间
			total += q.top() - p[i].come;
			q.push(q.top() + p[i].time);
			q.pop();
		}
	}
	(!cnt) ? printf("0.0\n") : printf("%.1lf", (total / 60.0) / cnt);
	return 0;
}
```

**可以学习的**

1、优先队列的定义，三个参数，<类型，容器，顺序>，greater是升序

2、优先队列的用处，队列总是有序的

### 1018 Public Bike Management

题目大意：城市中的自行车站，最大容量为一个偶数$C_{max}$，定义车站里的自行车数量恰好为$C_{max}$ / 2时为完美状态；若一个车站不是完美状态，位于节点0处的调度中心就会携带或者在路上收集一定数量的自行车前往这个车站，以保证一路上所有车站都变为完美状态；现给出$C_{max}$、车站数量n、不完美车站$S_p$的数量及编号、m条边及每条边的长度；目的是求出最短路径(包括长度和具体路径)，如果有多条最短路径则输出所带去自行车数量最小的那条，若还有多条则求出所带回自行车数量最少的那条。

解题思路：Dijkstra + DFS；如果只有Dijkstra是不可以的，因为minNeed和minBack在路径上的传递不满足最优子结构，不是简单的相加的过程，只有在所有路径都确定了之后才能区选择最小的need和最小的back。那么，Dijkstra求最短路径，过程中将最短路径以邻接链表的形式存下来；dfs求minNeed、minBack和最终的path，总体思路是利用深度优先搜索先组装出一条条路径，然后求出这些条路径的need和back，再取最小值minNeed和minBack。

核心代码

```C++
const int inf = 99999999;
int cmax, n, sp, m;
int minNeed = inf, minBack = inf;
int e[510][510], dis[510], weight[510];
bool visit[510];  // 以上是写Dijkstra所需的基本变量
vector<int> pre[510], path, temppath;  // pre为邻接链表，显式地存放图的连接关系
void dfs(int v) {
	temppath.push_back(v);
	if (v == 0) {  // 从终点一直搜索到起点，到起点后才进入这个if
		int need = 0, back = 0;
		for (int i = temppath.size() - 1; i >= 0; i--) {  // 从起始点遍历到终点，去的路上就要使所有车站满足完美状态
			int id = temppath[i];
			if (weight[id] > 0) {  // 如果比完美状态大，就需要把多余的自行车带走
				back += weight[id];
			} else {
				if (back > (0 - weight[id])) {  // 如果有车站少自行车，且带回来的back能够满足
					back += weight[id];  // 则back吐出0 - weight[id]辆车，即back减小
				} else {  // 如果有车站少自行车，但带回来的back满足不了，
					need += ((0 - weight[id]) - back);  // back吐出来后还有的缺口只能由调度中心增加带出来的车辆，即need增加
					back = 0;  // 让back全吐出来，即置0
				}
			}
		}
		if (need < minNeed) {  // 先need最小
			minNeed = need;
			minBack = back;
			path = temppath;
		} else if (need == minNeed && back < minBack) {  // 若need已经最小，则再取back最小
			minBack = back;
			path = temppath;
		}
		temppath.pop_back();  // 这条路径完成，pop掉尾巴的一个元素，去找第二条路径
		return;
	}
	for (int i = 0; i < pre[v].size(); i++) {
		dfs(pre[v][i]);  // 从后往前深度搜索，只要节点之间先连接，就去搜索
	}
	temppath.pop_back();  // 搜索进去可能扑了个空，那就需要将刚进入函数的push_back给pop掉
	return;
}
int main() {
	fill(e[0], e[0] + 510 * 510, inf);
	fill(dis, dis + 510, inf);
	scanf("%d %d %d %d", &cmax, &n, &sp, &m);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &weight[i]);
		weight[i] = weight[i] - cmax / 2;  // 现在0是完美状态
	}
	for (int i = 0; i < m; i++) {
		int a, b, c;
		scanf("%d %d %d", &a, &b, &c);
		e[a][b] = e[b][a] = c;
	}  // 输入完成
	// 开始写Dijkstra算法
	dis[0] = 0;  // 这题节点0为起始点
	for (int i = 0; i <= n; i++) {
		int u = -1, minn = inf;
		for (int j = 0; j <= n; j++) {  // 每次取出未访问节点中距离最小的，记为u
			if (visit[j] == false && dis[j] < minn) {
				u = j;
				minn = dis[j];
			}
		}
		if (u == -1) break;
		visit[u] = true;
		for (int v = 0; v <= n; v++) {
			if (visit[v] == false && e[u][v] != inf) {
				if (dis[u] + e[u][v] < dis[v]) {
					dis[v] = dis[u] + e[u][v];  // 每次都有的最基本的更新
					pre[v].clear();
					pre[v].push_back(u);
				} else if (dis[u] + e[u][v] == dis[v]) {
					pre[v].push_back(u);  // 记下u到v的最短的所有路径
				}
			}
		}
	}
	dfs(sp);
	printf("%d 0", minNeed);
	for (int i = path.size() - 2; i >= 0; i--) printf("->%d", path[i]);
	printf(" %d", minBack);
	return 0;
}
```

**可以学习的**

1、Dijkstra的思想及其写法，这里主要是写法，思想在1003中也有说明

2、dfs的思想及其写法，需要特别注意用dfs组装最短路径时push()和pop()的位置

3、若题目的某个部分有二义性，在纸上模拟一遍未尝不是一种方法

### 1019 General Palindromic Number

题目大意：给出2个整数a和b，问十进制下的a在b进制下是否为回文数；若是，输出Yes，否输出No，并且输出a在b进制下的表示，以空格隔开

解题思路：先将a转化为b进制的形式，保存在数组里，比较数组左右两端是否对称

核心代码 与1015有段代码是一样的

```C++
int main() {
	int n, radix;
	scanf("%d %d", &n, &radix);
	int len = 0, arr[100];
	do {  // 将数值逐位提取到数组中存储，下标小的是低位，长度为len
		arr[len++] = n % radix;
		n = n / radix;
	} while (n != 0);
	int flag = 0;
	for (int i = 0; i < len / 2; i++) 
		if (arr[i] != arr[len - i - 1]) {
			printf("No\n");
			flag = 1;
			break;
		}
	if (!flag) printf("Yes\n");
	printf("%d", arr[len - 1]);
	for (int i = len - 2; i >= 0; i--) printf(" %d", arr[i]);
	return 0;
}
```

**可以学习的**

1、1015的2，将数值逐位提取到数组中存储，以及将逐位存储的radix进制的数转化为十进制，的写法

### 1020 Tree Traversals

题目大意：给定一棵二叉树的后序遍历和中序遍历，目的是输出其层序遍历的结果；题目假设数的键值是互不相等的正整数

解题思路：与已知后序中序转换为前序的思路相近，均不需要先构造二叉树再广度优先搜索；已知后序中序转换为前序，因为后序的最后一个总是根结点，令i在中序中找到该根结点，则i把中序分为两部分，左边是左子树，右边是右子树；因为是输出先序（根左右），所以先打印出当前根结点，然后打印左子树，再打印右子树。那么，在此前基础上，加一个变量index，表示当前的根结点在二叉树中所对应的下标（从0开始），所以进行一次输出先序的递归过程中，就可以把根结点下标index及所对应的值存储在map<int, int> level中，map是有序的，会根据index从小到大自动排序，这样递归完成后level中的值就是层序遍历的顺序；

核心代码

```C++
vector<int> post, in;
map<int, int> level;  // map是有序的，它自己会根据index从小到大排序
void pre(int root, int start, int end) {  // 已知后序和中序求前序的函数，root是对后续说的，start和end是对中序说的
	if (start > end) return;
	int i = start;
	while (i < end && in[i] != post[root]) i++;
	printf("%d ", post[root]);
	pre(root - (end - i) - 1, start, i - 1);  // post中的根节点下标减去右子树长度，再减去根的长度1，就是左子树长度，也是其根节点的下标
	pre(root - i, i + 1, end);
}

void pre2(int root, int start, int end, int index) {  // 已知后序和中序求层序的函数，基于pre修改而来
	if (start > end) return;
	int i = start;
	while (i < end && in[i] != post[root]) i++;
	level[index] = post[root];  // index表示当前节点在二叉树中所对应的下标
	pre2(root - (end - i) - 1, start, i - 1, 2 * index + 1);
	pre2(root - 1, i + 1, end, 2 * index + 2);
}
```

**可以学习的**

1、已知后序与中序输出前序，无需构造二叉树的写法

2、已知后序与中序输出层序，无需构造二叉树的写法

3、map是有序的，它自己会根据index从小到大排序

### 1021 Deepest Root

题目大意：给一个无向无环图，目的是找出其中的最长路，可以理解为求一棵树的直径

解题思路：首先dfs判断它有几个连通分量，若多个，则输出Error:x components，若只有一个，则说明给的是一棵树；那么，为了求这棵树的直径，做2遍dfs，第一遍任取起点dfs，用数组记录每个节点在dfs搜索中距起点的距离，其中有最大距离，记为Max，将所有距离为Max的节点存入集合set；第二遍从集合中任取一个元素，以此为起点dfs，重复第一次的操作；集合中元素是不重复的，按升序输出集合中的元素即可

核心代码

```C++
int n, maxheight = 0;
vector<vector<int>> v;
bool visit[10010];
set<int> s;
vector<int> temp;
void dfs(int node, int height) {
	if (height > maxheight) {  // 将高度(深度)最大的节点存进temp
		temp.clear();
		temp.push_back(node);
		maxheight = height;
	}
	else if (height == maxheight) {
		temp.push_back(node);
	}
	visit[node] = true;  // 这4行才是基础的dfs
	for (int i = 0; i < v[node].size(); i++)
		if (visit[v[node][i]] == false)
			dfs(v[node][i], height + 1);
}
int main() {
	scanf("%d", &n);
	v.resize(n + 1);
	int a, b, cnt = 0, s1 = 0;
	for (int i = 0; i < n - 1; i++) {
		scanf("%d %d", &a, &b);
		v[a].push_back(b);
		v[b].push_back(a);
	}  // 经典的对图的输入写法，这里的v选择了用多少开多少的写法
	for (int i = 1; i <= n; i++) {
		if (visit[i] == false) {
			dfs(i, 1);
			if (i == 1) {  // 找连通分量时的dfs被二次利用
				if (temp.size() != 0) s1 = temp[0];  // s1是从第一遍dfs后的最大距离节点中任取的一个，后面第二遍用
				for (int j = 0; j < temp.size(); j++) 
					s.insert(temp[j]);  // 一侧的最大距离节点已被找出，存储
			}
			cnt++;  // cnt代表强连通分量个数
		}
	}
	if (cnt >= 2) printf("Error: %d components", cnt);
	else {
		temp.clear();
		maxheight = 0;
		fill(visit, visit + 10010, false);
		dfs(s1, 1);  // 第二次dfs，从任选的s1节点出发，即可找到距离最长的所有节点
		for (int i = 0; i < temp.size(); i++)
			s.insert(temp[i]);  // 存入集合s，集合会自动去重和排序
		for (auto it = s.begin(); it != s.end(); it++)
			printf("%d\n", *it);
	}
	return 0;
}
```

**可以学习的**

1、集合set的性质及使用，set会自动去重和排序，且为升序

2、求树的直径的方法，仅需2次dfs

3、求连通分量个数的方法，dfs是一种，另一种并查集会更快，现在还不会

### 1022 Digital Library

题目大意：模拟数字图书馆的查询功能；给出n本书的信息（字符串内部有空格），以及m个查询请求，每个请求以数字编号打头，数字代表相应的查询命令，编号后是查询的搜索词；目的是输出这条查询请求、满足条件的书的id，若没有，则输出Not Found

解题思路：首先需要把书的信息存储起来；这道题比较特殊，只需要输出书的编号，那么建立除id外的其它信息与id的映射map<string, set\<id>>，是一个非常好的方式，即一本书的信息被拆分为多个信息存在不同的map中，形成一个分立的信息对应一个集合，集合里是符合该条件的书的id；由于输入的字符串内部有空格，得用getline(cin，string)；查询时，用map里的函数find；传参时，map一定要用引用传过去，否则编译器会将整个map拷贝过去，慢，而传引用只传一个地址，快。

核心代码

```C++
map<string, set<int>> title, author, key, pub, year;
void query(map<string, set<int>>& m, string& str) {
	if (m.find(str) != m.end())
		for (auto it = m[str].begin(); it != m[str].end(); it++)
			printf("%07d\n", *it);
	else 
		printf("Not Found\n");
}
int main() {
	int n, m, id, num;
	scanf("%d", &n);
	string ttitle, tauthor, tkey, tpub, tyear;
	for (int i = 0; i < n; i++) {
		scanf("%d\n", &id);
		getline(cin, ttitle);
		title[ttitle].insert(id);  // 将多个id放入集合，与要被查询的title映射
		getline(cin, tauthor);
		author[tauthor].insert(id);
		while (cin >> tkey) {
			key[tkey].insert(id);  // 关键词可以有多个，分开再与id映射
			char c = getchar();  // 可能读到空格或回车
			if (c == '\n') break;  // 若是空格，则继续
		}
		getline(cin, tpub);
		pub[tpub].insert(id);
		getline(cin, tyear);
		year[tyear].insert(id);
	}
	scanf("%d", &m);
	for (int i = 0; i < m; i++) {
		scanf("%d: ", &num);
		string temp;
		getline(cin, temp);
		cout << num << ": " << temp << endl;  // 这里不能用printf，string类型的temp会乱码
		if (num == 1) query(title, temp);
		else if (num == 2) query(author, temp);
		else if (num == 3) query(key, temp);
		else if (num == 4) query(pub, temp);
		else if (num == 5) query(year, temp);
	}
	return 0;
}
```

**可以学习的**

1、内部有空格的字符串得用getline输入，getline(cin, string)

2、当输入一行不知道个数的以空格隔开的字符串时，用while(cin>>s) c = getchar; 判断c是否为换行\n

3、printf是C的函数，不能直接输出C++才有的string数据类型，换cout就行

4、空间换时间，妙用STL的组合，这里指map<string, set\<int>>

### 1023 Have Fun with Numbers

题目大意：给出一个长度不超过20的整数，问这个整数乘以2后，是否为原来数位的一个排列，是不是还是那些数字；是则输出Yes，否则No，以及乘以2后的那个数

解题思路：~~用python写很方便~~ 使用char数组存储这个数，每个数位乘以2并进位；设立book来标记数位出现的次数

核心代码

```C++
int book[10]; // 记录每个数字的个数
int main() {
	char num[22];
	scanf("%s", num);
	int flag = 0, len = strlen(num);  // 轻松读入char数组并且获取其长度
	for (int i = len - 1; i >= 0; i--) {  // 从个位开始
		int temp = num[i] - '0';  // 取出一个数位
		book[temp]++;  // 该数位加1
		temp = temp * 2 + flag;  // flag是进位与否的标志
		flag = 0;
		if (temp >= 10) {
			temp = temp - 10;
			flag = 1;
		}
		num[i] = temp + '0';  // 乘以2后的数位
		book[temp]--;  // 乘以2后的数位减1
	}
	int flag1 = 0;
	for (int i = 0; i < 10; i++) 
		if (book[i] != 0) {
			flag1 = 1;
			break;
		}
	printf("%s", (flag == 1 || flag1 == 1) ? "No\n" : "Yes\n");
	if (flag == 1) printf("1");  // 最高位进位了的情况
	printf("%s", num);
	return 0;
}
```

**可以学习的**

1、大数乘以2的写法，涉及进位的过程

2、获取输入的char数组的长度，用strlen()函数，在cstring头文件中

### 1024 Palindromic Number

题目大意：给一个整数n和允许操作的次数cnt，定义一次操作为：将n反转再与自己相加；目的是求出需要多少次操作能变为一个回文数，若不能在cnt次内完成，则输出在第cnt次时的结果

解题思路：~~用python写很方便~~ 用字符串s存储这个整数，因为此题中容易溢出long；实现大整数相加；

核心代码

```C++
string add(string s, string t) {  // 大整数加法函数， s = s + t
	int len = s.length(), carry = 0;
	for (int i = len - 1; i >= 0; i--) {  // 从个位开始
		s[i] = s[i] + t[i] + carry - '0';
		carry = 0;
		if (s[i] > '9') {
			s[i] = s[i] - 10;
			carry = 1;  // 有进位，由于是加法，最多进1
		}
	}
	if (carry) s = '1' + s;  // 若最高位有进位，则再添个1
	return s;
}
```

**可以学习的**

1、大整数加法

### 1025 PAT Ranking

题目大意：有n个考场，每个考场有k个学生，给出每个学生的编号和分数；目的是求出一张排名表，包含编号、总排名、考场号、考场内排名

解题思路：用结构体存储每个学生的编号、分数、总排名、考场号、考场内排名；先按考场内排名，存储；然后赋值给总的数组fin，再进行总排名；输出。排名思路与1012相近

核心代码

```C++
struct student {
	long long int id;
	int score, finrank, loca, locarank;
};
bool cmp1(student a, student b) {
	return a.score != b.score ? a.score > b.score : a.id < b.id;
}
int main() {
	int n, m;
	cin >> n;
	vector<student> fin;
	for (int i = 0; i < n; i++) {
		cin >> m;
		vector<student> v(m);
		for (int j = 0; j < m; j++) {
			scanf("%lld %d", &v[j].id, &v[j].score);
			v[j].loca = i + 1;  // 为考场号赋值
		}
		sort(v.begin(), v.end(), cmp1);  // 先按考场内排名
		v[0].locarank = 1;
		fin.push_back(v[0]);
		for (int j = 1; j < m; j++) {
			v[j].locarank = (v[j].score == v[j - 1].score) ? (v[j - 1].locarank) : (j + 1);  // 把排名存入结构体
			fin.push_back(v[j]);  // 赋值给总的数组
		}
	}
	sort(fin.begin(), fin.end(), cmp1);  // 再进行总排名
	fin[0].finrank = 1;
	for (int j = 1; j < fin.size(); j++) {
		fin[j].finrank = (fin[j].score == fin[j - 1].score) ? (fin[j - 1].finrank) : (j + 1);  // 把总排名存入结构体
	}
	printf("%d\n", fin.size());  // 开始输出
	for (int i = 0; i < fin.size(); i++) 
		printf("%013lld %d %d %d\n", fin[i].id, fin[i].finrank, fin[i].loca, fin[i].locarank);
	return 0;
}
```

**可以学习的**

1、排名问题的通用写法，定义结构体，sort，遍历赋值排名

### 1027 Colors in Mars

题目大意：给3个范围在0—168的十进制数，目的是将其转换为13进制数输出

解题思路：因为0~168的十进制转换为13进制不会超过两位数，所以这个两位数为(num / 13)(num % 13)构成的数字

核心代码

```C++
int main() {
	char c[14] = {"0123456789ABC"};
	printf("#");
	for (int i = 0; i < 3; i++) {
		int num;
		scanf("%d", &num);
		printf("%c%c", c[num / 13], c[num % 13]);
	}
	return 0;
}
```

### 1028 List Sorting

题目大意：模拟excel中的根据某一列的排序的功能；给出n行3列数据，根据c的值是1还是2还是3，对相应的列排序。第一列升序，第二列不降序，第三列不降序

解题思路：用结构体存储，写cmp函数，sort排序；

```C++
const int maxn = 100001;
struct node {
	int id, score;
	char name[10];
} stu[maxn];
int c;
bool cmp1(node a, node b) {
	if (c == 1) {
		return a.id < b.id;
	}
	else if (c == 2) {
		if (strcmp(a.name, b.name) == 0) { return a.id < b.id; }
		return strcmp(a.name, b.name) <= 0;
	}
	else if (c == 3) {
		if (a.score == b.score) { return a.id < b.id; }
		return a.score < b.score;
	}
}
int main() {
	int n;
	scanf("%d %d", &n, &c);
	for (int i = 0; i < n; i++) 
		scanf("%d %s %d", &stu[i].id, &stu[i].name, &stu[i].score);
	sort(stu, stu + n, cmp1);
	for (int i = 0; i < n; i++) 
		printf("%06d %s %d\n", stu[i].id, stu[i].name, stu[i].score);
	return 0;
}
```

**可以学习的：**

1、按照字符串排序时，若用char数组存储，则使用strcmp()函数比较，升序写成return strcmp(a.name, b.name) < 0；

### 1029 Median

题目大意：给出两个已排列序列，求这两个序列合并后的中位数

解题思路：既然两个数组都是递增的顺序，可以借助归并的思想；在归并途中，若找到了中位数，就可以提前break，归并过程中也不需要将每个数都存下来；若一个序列遍历完了还没找到 ，可以通过简单推理直接找到中位数所在的位置

核心代码

```C++
const int maxn = 200005;
int n1, n2, a1[maxn], a2[maxn], cnt = 0, i, j, ans;
int main() {
	scanf("%d", &n1);
	for (i = 1; i <= n1; i++) scanf("%d", &a1[i]);
	scanf("%d", &n2);
	for (i = 1; i <= n2; i++) scanf("%d", &a2[i]);
	int target = (n1 + n2 + 1) / 2;  // 中位数所在位置的下标
	i = 1, j = 1;
	while (i <= n1 && j <= n2) {
		ans = a1[i] <= a2[j] ? a1[i++] : a2[j++];  // 归并的思想
		if (++cnt == target) break;  // 找到中位数就可以溜了
	}
	if (i <= n1 && cnt < target)  // a2遍历完了还没找到中位数
		ans = a1[i + (target - (cnt + 1))];  // i和target的单位是下标，而cnt是指针移动的位置，需要+1才能平等地参与前者的运算
	else if (j <= n2 && cnt < target) 
		ans = a2[j + (target - (cnt + 1))];
	printf("%d", ans);
	return 0;
}
```

**可以学习的**

1、归并的思想，将2个有序序列在O(n)的时间复杂度中合并为一个有序序列

### 1030 Travel Plan

题目大意：给一幅无向图，n个城市、m条边、起点s、终点d以及每条边的长度和花费；目的是求最短路径，其次，要花费最少；输出最短路径、最短距离、最少花费；

解题思路：与1018相似，都是先用Dijistra求出多条最短路径，再用DFS求出每条路径的花费。Dijistra+DFS；Dijkstra记录最短路径pre数组，然后用dfs求最短路径中花费最少的一条以及它的路径path，最后输出path数组和mincost；注意，路径path因为是从末端一直压入push_back到path里面的，所以要输出路径的时候倒着输出

核心代码

```C++
const int inf = 9999999;
int n, m, s, d;
int e[510][510], dis[510], cost[510][510];  // 分别存边的长度(第一边权)、到某点的距离、第二边权
bool visit[510];
vector<int> pre[510];  // pre是记录最短路径的邻接链表。以上是写Dijistra所需的基本变量
vector<int> path, temppath;  // 写dfs用的
int mincost = inf;  // 此题的由第二边权衍生出来的目标函数
void dfs(int v) {
	temppath.push_back(v);
	if (v == s) {  // 此时，一条最短路径已被构造出来了，去算目标函数
		int tempcost = 0;  // 在同样是最短路径的前提下，tempcost是目标函数，求最小
		for (int i = temppath.size() - 1; i > 0; i--) {  // 从起始点遍历到终点
			int id = temppath[i], nextid = temppath[i - 1];
			tempcost += cost[id][nextid];  // 遍历每条边的第二边权，这题是价格
		}  // 至此，算出了一条最短路径的目标函数
		if (tempcost < mincost) {  // 取最小的目标函数
			mincost = tempcost;  // 更新最小值
			path = temppath;  // 更新最后要输出的路径
		}
		temppath.pop_back();  // 把这条算完的路径给弹出去
		return;
	}
	for (int i = 0; i < pre[v].size(); i++) 
		dfs(pre[v][i]);
	temppath.pop_back();
}
int main() {
	fill(e[0], e[0] + 510 * 510, inf);  // 初始化所有点之间均不可达，即距离无限远
	fill(dis, dis + 510, inf);  // 
	scanf("%d %d %d %d", &n, &m, &s, &d);  // 开始输入
	for (int i = 0; i < m; i++) {
		int a, b;
		scanf("%d %d", &a, &b);
		scanf("%d", &e[a][b]);
		e[b][a] = e[a][b];
		scanf("%d", &cost[a][b]);
		cost[b][a] = cost[a][b];
	}  // 输入完成。下面开始写Dijistra
	dis[s] = 0;  // 以s为起始点
	for (int i = 0; i < n; i++) {
		int u = -1, minn = inf;
		for (int j = 0; j <= n; j++) {  // 每次取出未访问节点中距离最小的，记为u
			if (visit[j] == false && dis[j] < minn) {
				minn = dis[j];
				u = j;
			}
		}
		if (u == -1) break;
		visit[u] = true;  // 走到u节点，因为距离上一个节点最短
		for (int v = 0; v < n; v++) {  // 去找离u最近的下一个节点
			if (visit[v] == false && e[u][v] != inf) {
				if (dis[u] + e[u][v] < dis[v]) {
					dis[v] = dis[u] + e[u][v];
					pre[v].clear();
					pre[v].push_back(u);  // u才是到v最近的
				}
				else if (dis[u] + e[u][v] == dis[v]) {
					pre[v].push_back(u);  // 不止一个u到v最近
				}
			}
		}
	}
	dfs(d);  // 从终点开始往回，从pre邻接链表中“提取”出最短路径，并计算每条最短路径的花费
	for (int i = path.size() - 1; i >= 0; i--) {
		printf("%d ", path[i]);
	}
	printf("%d %d", dis[d], mincost);
	return 0;
}
```

**可以学习的：**

1、Dijistra的写法，与1003和1018几乎完全一致；

2、这种求最短路的同时又有其它目标的题目，可以采取：先用Dijistra求出多条最短路径，再用DFS遍历求出每条路径的目标；

### 1031 Hello World for U

题目大意：将所给字符串按“U”形输出，尽可能保证3边n1、n2、n3差不多长

解题思路：n1+n2+n3=N+2，N为字符串长度；又n1=n3，可能多出来1个或2个，都加到底部的n2上

核心代码

```C++
int main() {
	char c[81], u[30][30];
	memset(u, ' ', sizeof(u));  // 初始化输出全为空格
	scanf("%s", c);  // 输入字符串
	int n = strlen(c) + 2;
	int n1 = n / 3, n2 = n / 3 + n % 3, index = 0;
	for (int i = 0; i < n1; i++) u[i][0] = c[index++];  // 输出左边一列
	for (int i = 1; i < n2 - 1; i++) u[n1 - 1][i] = c[index++];  // 输出除左右边上2个的底部
	for (int i = n1 - 1; i >= 0; i--) u[i][n2 - 1] = c[index++];  // 输出右边一列
	for (int i = 0; i < n1; i++) {
		for (int j = 0; j < n2; j++) {
			printf("%c", u[i][j]);
		}
		printf("\n");
	}
	return 0;
}
```

**可以学习的：**

1、对于输出形状的题，先用数组存起来，最后再输出，是一个不错的方法

### 1032 Sharing

题目大意：求两个以链表存储的单词的共同后缀的首地址；给出2个链表的起始地址，共n个节点，包括地址、一个字母、下一节点地址；目的是求两个链表的首个共同节点的地址，如果没有，则输出-1

解题思路：用结构体存储每一个节点，且用结构体数组存储链表，因为题目给的地址是5位整数；node[i]表示地址为i的节点，key表示值，next表示下一个节点的地址，flag表示第一个链表中的每一个节点的个数，初始化为0；先遍历第一个链表，每个节点的flag置为1，相当于遇到了一次；再遍历第二个链表，遇到flag为1的节点，就说明二者从这里开始重复，因为从这里开始遇到的节点次数为2次了。

核心代码

```C++
struct NODE {
	char key;
	int next;
	bool flag;
} node[100005];
int main() {
	int s1, s2, n, a, b;
	scanf("%d %d %d", &s1, &s2, &n);
	char data;
	for (int i = 0; i < n; i++) {
		scanf("%d %c %d", &a, &data, &b);
		node[a] = { data, b, false };
	}  // 输入完成
	for (int i = s1; i != -1; i = node[i].next)  // 遍历第一个序列
		node[i].flag = true;  // 将第一个序列的flag置为true，相当于均遇到一次
	for (int i = s2; i != -1; i = node[i].next) 
		if (node[i].flag == true) {  // 碰到第一个true就说明二者从这里开始重复，遇到了第二次
			printf("%05d", i);
			return 0;
		}
	printf("-1");
	return 0;
}
```

**可以学习的：**

1、用结构体实现链表，仅限于地址长度较小的，因为要用结构体数组的下标去代表节点的地址，5位基本上是极限了；

2*、第一次碰到链表，但这题的链表不太”正式“，希望后面能再遇到链表

### 1033 To Fill or Not to Fill

题目大意：高速公路行驶，每个加油站油价不同，从A到B最少花多少钱。给出油箱的容量、到目的地距离、每升油能跑的距离、加油站总数以及每个加油站的油价和距起始点的距离

解题思路：贪心。

0.假设增加一个目的地处的加油站，距离为目的地的距离，价格为0，考虑从0距离开始能否到达最后一个加油站的问题
1.因为先开始没有油，所以如果所有的加油站距离都没有等于0的，那么说明车哪也去不了，直接输出并return
2.将加油站按照距离dis从小到大排序
3.先去第一个加油站，设置变量nowdis表示当前所在的距离，maxdis是能够到达的最大距离，nowprice是当前的站点的价格，totalPrice是总的价格，leftdis是到达站点时所剩的油能开的距离。

贪心思想：

0.寻找比自己距离远的，到能够到达的最大距离之间的加油站，看他们的油价。如果找到了更低价格的油价，就加油到刚好能到达那个加油站的距离的油，然后去那个更低价格的加油站（有更低的我一分都不想多花在别的距离上，只加到刚好满足更低价格的加油站的距离就行，那样以后的路程我就可以以更低的价格行驶啦）
1.如果找不到更低的，就找尽可能低的油价的加油站，在当前加油站加满油之后过去。因为想要让路程上使用的尽可能是低价的油，既然没有比当前更低价格的了，就让油箱加到最大值，这样能保证利益最大化，保证最大的距离使用的是便宜的油。

核心代码

```C++
const int inf = 99999999;
struct station {
	double price, dis;  // 每个加油站的油价和距起始点距离
};
bool cmp1(station a, station b) {
	return a.dis < b.dis;
}
int main() {
	double cmax, d, davg;
	int n;
	scanf("%lf %lf %lf %d", &cmax, &d, &davg, &n);
	vector<station> sta(n + 1);
	sta[0] = { 0.0, d };
	for (int i = 1; i <= n; i++) {
		scanf("%lf %lf", &sta[i].price, &sta[i].dis);
	}  // 输入完成
	sort(sta.begin(), sta.end(), cmp1);
	double nowdis = 0.0, maxdis = 0.0, nowprice = 0.0, totalPrice = 0.0, leftdis = 0.0;
	if (sta[0].dis != 0) {
		printf("The maximum travel distance = 0.00");
		return 0;  // 很特殊的情况，第一站不在起始点处，那没有油就开不起来
	}
	else {
		nowprice = sta[0].price;  // 初始化当前油价为起始点油价
	}
	while (nowdis < d) {  // 没走到终点就继续
		maxdis = nowdis + cmax * davg;  // 加满油能跑的最大距离
		double minPriceDis = 0.0, minPrice = inf;
		int flag = 0;
		for (int i = 1; i <= n && sta[i].dis <= maxdis; i++) {  // 去遍历能到达的加油站
			if (sta[i].dis <= nowdis) continue;  // 跳过已经走过的加油站
			// 情况一
			if (sta[i].price < nowprice) {  // 如果后面有加油站的油价比当前的便宜，就去最近的那个，大赚
				totalPrice += nowprice * (sta[i].dis - nowdis - leftdis) / davg;  // 油价 * 所需油数量
				leftdis = 0.0;
				nowprice = sta[i].price;
				nowdis = sta[i].dis;
				flag = 1;
				break;
			}
			if (sta[i].price < minPrice) {  // 如果没有大赚的情况，就去找尽可能低的油价
				minPrice = sta[i].price;
				minPriceDis = sta[i].dis;
			}
		}
		// 情况二
		if (flag == 0 && minPrice != inf) {  // 没有比当前加油站更低的油价，只能去其中最低的那个加油站，当场加满，少亏一点
			totalPrice += nowprice * (cmax - leftdis / davg);  // 油价 * (加满所需油数量 = 油箱容量 - 上次剩下的油)
			leftdis = cmax * davg - (minPriceDis - nowdis);  // 
			nowprice = minPrice;
			nowdis = minPriceDis;
		}
		// 情况三
		if (flag == 0 && minPrice == inf) {  // 最大距离无法抵达不了下一个车站，为不可达的情况
			nowdis += cmax * davg;  // 索性加满，能开多远开多远
			printf("The maximum travel distance = %.2lf", maxdis);
			return 0;
		}
	}
	printf("%.2lf", totalPrice);
	return 0;
}
```

**可以学习的：**

1、贪心的思想，总是做出在当前看来是最好的选择。一般分为两种主要的情况，能最好就最好，不行就次好

### 1034 Head of a Gang

题目大意：背景是利用电话记录找出黑帮团伙。给出n条通话记录，包含双方姓名和通话时长，还有一个阈值k；如果一个团伙人数超过2人并且通话总时长超过k，那么令团伙里面的自身权值的最大值为头目，输出每个团伙的头目以及他们团伙里面的人数。

解题思路：总的来说是需要判断一个图的连通分量的个数，用图的遍历解决，深度优先遍历
1.因为给的是字母，要用两个map把它们转换成数字，从1开始排列命名所有不同的人的id，存储在两个map里面，一个字符串对应id，一个id对应字符串，方便查找，正好顺便统计了总共的人数idNumber。
2.建立两个数组，weight和G，分别存储每个节点的权值和每个边的权值，因为这两个权值都要求出后再去判断。
3.用传递引用的方法深度优先dfs，这样传入的参数在dfs后还能保存想要求得的值
4.遍历过一条边之后就把这条边的权值设为0（ G\[u][v] = G\[v][u] = 0;）防止出现回路遍历死循环

核心代码

```C++
map<string, int> stringToInt;
map<int, string> intToString;
map<string, int> ans;
int idNumber = 1, k;

int stoifunc(string s) {  // 将字符串(名字一类的)转换成从1开始数字编号
	if (stringToInt[s] == 0) {
		stringToInt[s] = idNumber;
		intToString[idNumber] = s;  // 对应关系需要2个map来完成
		return idNumber++;
	}
	else {
		return stringToInt[s];
	}
}
int weight[2010], G[2010][2010];  // weight存点权，G存边权
bool visit[2010];  // dfs求连通分量个数时要用
void dfs(int u, int &head, int &numMember, int &totalweight) {
	numMember++;  // 节点数加一
	if (weight[u] > weight[head])
		head = u;
	visit[u] = true;
	for (int v = 1; v < idNumber; v++) {
		if (G[u][v] > 0) {  // 这里不是传统的“未访问且相邻”条件，因为这里是要去遍历所有边，而非遍历节点
			totalweight += G[u][v];  // 此行目的之一：计算所有节点的点权之和，这里节点点权来源于与之相邻的边
			G[u][v] = G[v][u] = 0;  // 防止重复遍历同一条边
			if (visit[v] == false) {
				dfs(v, head, numMember, totalweight);  // 这里每进去一次，能将一个节点v的所有信息算出来
			}
		}
	}
}
void dfsTrave() {  // 与dfs函数搭配，找一张图的连通分量，即子图
	for (int i = 1; i < idNumber; i++) {  // 找连通分量
		if (visit[i] == false) {
			int head = i, numMember = 0, totalweight = 0;
			dfs(i, head, numMember, totalweight);  // 从这里每进去一次，一定能找到一个子图
			if (numMember > 2 && totalweight > k) {  // 满足条件，人多于2、总边权大于阈值k
				ans[intToString[head]] = numMember;  // 给老大记上团伙人数，就是将每个子图与其人数对应起来
			}
			cout << numMember << " " << totalweight << endl;
		}
	}
}
```

**可以学习的：**

1、从一个节点出发，用dfs遍历图，基本代码就4行：置true、遍历for、判断状态、继续dfs；其中判断状态的写法有2种：if未访问且相邻、if相邻-置0-if未访问。前者作为遍历图中所有节点的方式，又有2种写法：若用邻接矩阵存图的连接关系，则判断为if(visit[i] == false && v\[node][i] == 1) 题1013；若用邻接链表存图的连接关系，则判断为if(visit[v\[node][i]] == false) 题1021。此题中，不是传统的“未访问且相邻”条件，因为这里是要去遍历所有边，而非遍历节点；所以采用“if相邻-置0-if未访问”的方法，将访问过的边的权重置为0，相当于给边也配了一个visit。

2、将字符串(名字一类的)转换成从1开始数字编号，使用2个map，函数在上面

### 1035 Password

题目大意：给定n个用户的姓名和密码，把密码中的1改为@，0改为%，l改为L，O改为o
如果不存在需要修改的密码，则输出There are n accounts and no account is modified。注意单复数，如果只有一个账户，就输出There is 1 account and no account is modified
解题思路：把需要改变的字符串改变后存储在字符串数组vector里面，根据数组里面元素的个数是否为0输出相应的结果

**可以学习的：**

1、switch的使用

### 1036 Boys vs Girls

题目大意：给出N个同学的信息，输出女生中的最高分获得者的信息与男生中最低分获得者的信息，并输出他们的分数差。如果不存在女生或者男生，则对应获得者信息处输出Absent，而且差值处输出NA

解题思路：用string类型的female和male保存要求的学生的信息，fscore和mscore处保存男生的最低分和女生的最高分；一开始设fscore为最低值-1，mscore为最高值101，最后根据分值是否为-1或者101来判断是否有相应的女生或者男生

**可以学习的：**

1、用string保存需要输出的所有信息，可能包括好几个字段，这样会少定义几个变量

2、求最大或最小值之前，定义一个最小或最大值是非常不错的选择，因为这样可以很快判断出有没有进if，还是原来的值就说明没进if

### 1037 Magic Coupon

题目大意：给出两个数字序列，从这两个序列中分别选取相同数量的元素进行一对一相乘，问能得到的乘积之和最大为多少

解题思路：把这两个序列都从小到大排序，将前面都是负数的数相乘求和，然后将后面都是正数的数相乘求和

### 1038 Recover the Smallest Number

题目大意：给n个由数字组成的字符串碎片，求它们拼接起来构成最小数字的方式

解题思路：分析可知，这是一个排序问题，2个数之间存在绝对的先后关系，即a + b < b + a，这里的“+”是指字符串拼接；所以构造一个cmp函数，sort()一下，就完事了；注意输出的时候要特殊考虑一下全0的情况

核心代码

```C++
bool cmp1(string a, string b) {
	return a + b < b + a;
}
int main() {
	int n;
	scanf("%d", &n);
	vector<string> v;
	string tmps, ans;
	for (int i = 0; i < n; i++) {
		cin >> tmps;
		v.push_back(tmps);
	}
	sort(v.begin(), v.end(), cmp1);
	for (int i = 0; i < n; i++) 
		ans += v[i];
	while (ans.length() != 0 && ans[0] == '0')  // 去除前导0
		ans.erase(ans.begin());
	if (ans.length() == 0)  // 有可能去除前导0后空了，就直接输出一个0
		cout << 0;
	else
		cout << ans;
	return 0;
}
```

**可以学习的：**

1、去除字符串前导0的方法：ans.erase(ans.begin())即可去除字符串的一个开头字符

### 1039 Course List for Student

题目大意：有k门课，给出选择每门课的学生姓名；现有n个学生来查询，给出他们的姓名，要求按顺序输出每个学生的选课情况

解题思路：用map<string, set\<int>>，输入时，将每个学生的姓名作为键，将课程的id插入到set集合中，set可以自己完成排序。

核心代码1

```C++
// 这道题用map<string, set<int>>可以过，最大的数据耗时369ms，内存45MB
int main() {
	int n, k;
	scanf("%d %d", &n, &k);
	int cosid, num;
	string name;
	map<string, set<int>> query;  // 数据结构
	for (int i = 0; i < k; i++) 
		scanf("%d %d", &cosid, &num);
		for (int j = 0; j < num; j++) {
			cin >> name;
			query[name].insert(cosid);
		}
	string qname;
	for (int i = 0; i < n; i++) {
		cin >> qname;
		int len = query[qname].size();
		cout << qname << " " << len;
		for (auto it = query[qname].begin(); it != query[qname].end(); it++) 
			printf(" %d", *it);
		printf("\n");
	}
	return 0;
}
```

解题思路2：考虑到string、cin、cout比较慢，存在超时的可能，可以使用hash(26\*26\*26\*10+10)将学生姓名变为int型，然后存储在vector里面

核心代码2

```C++
// 将姓名映射为编号，当做数组下标；最大的数据耗时71ms，内存10MB
int getid(char* name) {  // 将固定格式为3个大写字母+1个数字的名字转换成1个整型数，可理解为姓名的id
	int id = 0;
	for (int i = 0; i < 3; i++) {
		id = 26 * id + (name[i] - 'A');
	}
	id = id * 10 + (name[3] - '0');
	return id;
}
const int maxn = 26 * 26 * 26 * 10 + 10;
vector<int> v[maxn];  // 用数组的下标来索引每个学生姓名的id
int main() {
	int n, k, cosid, num, id = 0;
	char name[5];
	scanf("%d %d", &n, &k);
	for (int i = 0; i < k; i++) {
		scanf("%d %d", &cosid, &num);
		for (int j = 0; j < num; j++) {
			scanf("%s", name);
			id = getid(name);
			v[id].push_back(cosid);
		}
	}
	for (int i = 0; i < n; i++) {
		scanf("%s", name);
		id = getid(name);
		sort(v[id].begin(), v[id].end());
		printf("%s %lu", name, v[id].size());
		for (int j = 0; j < v[id].size(); j++)
			printf(" %d", v[id][j]);
		printf("\n");
	}
	return 0;
}
```

**可以学习的：**

1、string比char要慢，又string得用cin和cout来输入输出，而cin和cout比scanf和printf要慢，这就导致string+cin+cout的组合在某些特殊的情况下会超时；实在没办法的时候，可以尝试换成char

### 1040 Longest Symmetric String

题目大意：给一个字符串，带空格；目的是求出最长的对称子串的长度

解题思路1：回文子串要么是奇数子串要么是偶数子串，分2种情况，从中间开始往两边找；

解题思路2：动态规划。dp\[i][j]表示s[i]到s[j]所表示的字串是否是回文字串，只包含0和1；
递推方程：
当s[i] == s[j] : dp\[i][j] = dp\[i+1][j-1]
当s[i] != s[j] : dp\[i][j] =0
边界：dp\[i][j] = 1, dp\[i][i+1] = (s[i] == s[i+1]) ? 1 : 0
因为i、j如果从小到大的顺序来枚举的话，无法保证更新dp[i][j]的时候dp\[i+1][j-1]已经被计算过。因此不妨考虑按照子串的长度L和子串的初始位置i进行遍历，即第一遍将长度为3的子串的dp的值全部求出，第二遍通过第一遍结果计算出长度为4的子串的dp的值...这样就可以避免状态无法转移的问题；
首先初始化dp\[i][i] = 1, dp\[i][i+1]，把长度为1和2的都初始化好，然后从L = 3开始一直到 L <= len 根据动态规划的递归方程来判断；

核心代码

```C++
int dp[1010][1010];
int main() {
	string s;
	getline(cin, s);
	int len = s.length(), ans = 1;
	for (int i = 0; i < len; i++) {  // 先初始化边界值
		dp[i][i] = 1;
		if (i < len - 1 && s[i] == s[i + 1]) {
			dp[i][i + 1] = 1;
			ans = 2;
		}
	}
	for (int L = 3; L <= len; L++) {  // 字符串的长度
		for (int i = 0; i + L - 1 < len; i++) {  // 子串的初始位置
			int j = i + L - 1;  // i为子串左边界，j为子串右边界
			if (s[i] == s[j] && dp[i + 1][j - 1] == 1) {
				dp[i][j] = 1;
				ans = L;
			}
		}
	}
	printf("%d", ans);
	return 0;
}
```

### 1041 Be Unique

题目大意：给n个数字，按照读入顺序，哪个数字是第一个在所有数字中只出现一次的数字。如果所有数字出现都超过了一次，则输出None

解题思路：建立一个数组，用下标索引输入的数字，存储每个数字出现的次数，然后遍历一遍输入的顺序看是否有出现次数为1的数字

### 1042 Shuffling Machine

题目大意：模拟自动洗牌机；给出洗牌次数，以及每次洗牌的顺序，目的是求出洗完的结果

解题思路：使用start和end数组保存每一次变换的开始顺序和结束顺序（以1~54的编号存储），最后根据编号与扑克牌字母数字的对应关系输出end数组

### 1043 Is It a Binary Search Tree

题目大意1：给定一个整数键值序列，现请你编写程序，判断这是否是对一棵二叉搜索树或其镜像进行前序遍历的结果。

题目大意2：给出一串初始序列，让你以二叉搜索树的规则将初始序列的每个元素依次插入到二叉搜索树中，当所有元素(结点值)的结点都被插入到二叉搜索树时，就构建了一棵二叉搜索树。判断初始序列是先序序列还是先序序列的镜像序列，如果初始序列是先序序列，输出后序序列，如果初始序列是先序序列的镜像序列，输出后序序列的镜像序列。

解题思路1：假设它是二叉搜索树，一开始isMirror为false，根据二叉搜索树的性质将已知的前序转换为后序，转换过程中，如果发现最后输出的后序数组长度不为n，那就设isMirror为true，然后清空后序数组，重新再转换一次（根据镜面二叉搜索树的性质），如果依旧转换后数组大小不等于n，就输出NO否则输出YES （抽象）

解题思路2：构建二叉搜索树：以二叉搜索树的规则将初始序列的每个元素依次插入到二叉搜索树中,当所有元素(结点值)的结点都被插入到二叉搜索树时，就构建了一棵二叉搜索树。判断初始序列是什么序列，作出相应的输出

核心代码1

```

```

核心代码2

```C++
vector<int> pre, post, vec;  // 二叉搜索树的先序、后序、初始序列
struct node {
	int data;
	struct node* left, * right;
};
struct node* root = NULL;  // 初始化根节点地址为NULL
node* insert(node* root, int data) {  // 形参分别是当前树的根结点地址，要插入的节点值
	if (root == NULL) {
		root = new node();
		root->data = data;
		root->left = root->right = NULL;
		return root;
	}
	else if (data < root->data) {
		root->left = insert(root->left, data);
		return root;
	}
	else if (data >= root->data) {
		root->right = insert(root->right, data);
		return root;
	}
}
void preorder1(node* root) {  // 前序序列
	if (root != NULL) {
		pre.push_back(root->data);  // 根
		preorder1(root->left);  // 左
		preorder1(root->right);  // 右
	}
}
void postorder1(node* root) {  // 后序序列
	if (root != NULL) {
		postorder1(root->left);  // 左
		postorder1(root->right);  // 右
		post.push_back(root->data);  // 根
	}
}
```

**可以学习的：**

1、二叉树的构造方法，上面以insert()函数给出

2、二叉树的前序遍历、后序遍历，中序遍历类似

### 1044 Shopping in Mars

题目大意：求一串的数字中连续的一段，使得这个连续的段内数字的和恰好等于所期望的值m。如果不能找到恰好等于，就找让自己付出最少的价格（总和必须大于等于所给值）的那段区间，求所有可能的结果

简短版：找到和不小于一个给定值、但尽可能小的所有子串

解题思路1：简单模拟，有两个超时。一开始接收输入的时候可以直接保存它的sum函数，即sum[i]表示1～i的所有数字的总和；因为sum数组是递增的，用二分法查找；Func函数的作用是二分查找，求出第i个数到第j个数的和tempsum，并使这个和等于或接近目标值m

解题思路2： 两个指针，分别指向子串头尾，具体看代码（有优化，比如说找到一个满足要求的子串后，下一次扫描左指针右移一位，右指针的起始位置就保持在上一次右指针的位置即可）。
1.使用尺取法，如果取得范围总和大于需要pay的，删掉头部}
2.如果取得范围综合小于pay的，增加尾部
3.注意边界情况和没有相等的情况，细节可查看代码
4.利用一个minAns的变量进行记录答案数值

核心代码1

```C++
int n, m;
vector<int> sum, resultArr;
void Func(int i, int& j, int& tempsum) {
	int left = i, right = n;
	while (left < right) {
		int mid = (left + right) / 2;
		if (sum[mid] - sum[i - 1] >= m)
			right = mid;
		else
			left = mid + 1;
	}
	j = right;
	tempsum = sum[j] - sum[i - 1];
}
int main() {
	scanf("%d%d", &n, &m);
	sum.resize(n + 1);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &sum[i]);
		sum[i] += sum[i - 1];  // 输入时直接存从第1个位置开始的累加和
	}
	int minans = sum[n];
	for (int i = 1; i <= n; i++) {
		int j, tempsum;
		Func(i, j, tempsum);  // 求出第i个数到第j个数的和tempsum，并使这个和等于或接近目标值m
		if (tempsum > minans) continue;
		if (tempsum >= m) {  // 在和大于等于目标值m的情况下
			if (tempsum < minans) {  // 选择最小的那个m
				resultArr.clear();
				minans = tempsum;
			}
			resultArr.push_back(i);
			resultArr.push_back(j);  // 两个为一组输出
		}
	}
	for (int i = 0; i < resultArr.size(); i += 2) {
		printf("%d-%d\n", resultArr[i], resultArr[i + 1]);
	}
	return 0;
}
```

核心代码2

```c++
int a[100005], ans[100005];
int n, m, k = 0;
int minn = 999999999;
int main() {
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	int l = 1, r = 1;
	int s = 0;
	while (l <= n) {
		while (s < m && r <= n) {
			s += a[r];
			r++;
		}
		if (s < m) break;
		else if (s < minn) {
			k = 0;
			ans[++k] = l;
			ans[++k] = r - 1;  // 两个为一组答案
			minn = s;
		}
		else if (s == minn) {
			ans[++k] = l;
			ans[++k] = r - 1;  // 多加的一次r要减去
		}
		s -= a[l];
		l++;  // 左指针右移一位，右指针不需要动
	}
	for (int i = 1; i <= k; i += 2) {
		printf("%d-%d\n", ans[i], ans[i + 1]);
	}
	return 0;
}
```

**可以学习的：**

1、求子序列的和，在输入时直接计算并保存原序列第i个位置到开头的和，是一个不错的方法；后序求子序列的和，只需要做一次减法即可；

2、尺取法，也叫双指针法；顾名思义，像尺子一样取一段，尺取法通常是对数组保存一对下标，即所选取的区间的左右端点，然后根据实际情况不断地推进区间左右端点以得出答案。对于子序列相关的题目，值得考虑

### 1045 Favorite Color Stripe

题目大意：给出m种颜色作为喜欢的颜色（同时也包含顺序），然后给出一串长度为L的颜色序列，现在要去掉这个序列中的不喜欢的颜色，然后求剩下序列的一个子序列，使得这个子序列表示的颜色顺序符合自己喜欢的颜色的顺序，不一定要所有喜欢的颜色都出现

抽象出来：“求最长不下降子序列”

解题思路：因为喜欢的颜色是不重复的，把喜欢的颜色的序列按照存储到数组中，book[i] = j表示i颜色的下标为j。先在输入的时候剔除不在喜欢的序列中的元素，然后把剩余的保存在数组a中。按照最长不下降子序列的方式做，对于从前到后的每一个i，如果它前面的所有的j，能够找到一个j的下标book[j]比book[i]小，那就更新dp[i]使它 = max(dp[i], dp[j] + 1)；并且同时在每一次遍历完成一次j后更新maxn的值为长度的最大值，最后输出maxn

核心代码

```C++
int book[201], a[10001], dp[10001];
int d[10001];

int main() {
	int n, m, x, l, num = 0, maxn = 0;
	scanf("%d %d", &n, &m);  // 这里的n是多余信息，没有
	for (int i = 1; i <= m; i++) {
		scanf("%d", &x);
		book[x] = i;  // 给特定颜色序列按递增编号
	}
	scanf("%d", &l);
	for (int i = 0; i < l; i++) {
		scanf("%d", &x);
		if (book[x] >= 1) {  // 剔除那些不在喜欢的序列中的颜色
			a[num++] = book[x];  // 将剔除后的序列编号，1最小，m最大
		}
	}  // 至此，题目被转化成立“求最长不下降子序列”的问题，原序列就是a，长度为num
	/*由于这道题的数据量是1e4，可以用n2的方法AC，但1e4是极限了，再大就要换成下面那个nlogn的写法
	// n2
	for (int i = 0; i < num; i++) {
		dp[i] = 1;
		for (int j = 0; j < i; j++) {
			if (a[i] >= a[j])
				dp[i] = max(dp[i], dp[j] + 1);
		}
		maxn = max(maxn, dp[i]);
	} */
	// nlogn
	d[1] = a[0];  //初始化 
	maxn = 1;
	for (int i = 1; i < num; i++) { 
		if (d[maxn] <= a[i]) {  //如果可以接在len后面就接上
			d[++maxn] = a[i];
		}
		else {  //否则就找一个最该替换的替换掉 
			int j = upper_bound(d + 1, d + maxn + 1, a[i]) - d;  //找到第一个大于它的d的下标 
			d[j] = a[i];
		}
	}
	printf("%d", maxn);
	return 0;
}
```

**可以学习的：**

1、最长不降子序列的解法，2种，$n^2$和nlogn，具体可见上面代码

### 1046 Shortest Distance

题目大意：给出一串长度为n的数字序列，表示一个环形中n个节点之间的相邻距离；现给出m组节点对，一组节点对有2个节点的编号，目的是求出这2个节点之间的距离

解题思路：dis[i]记录每个点到初始点(1号)的距离。sum保存整个路径一圈的总和值。求得结果就是dis[right] – dis[left]和 sum – dis[right] – dis[left]中较小的那一个

核心代码

```C++
int main() {
	int n, m, sum = 0;
	scanf("%d", &n);
	vector<int> vec;  // 记录每个点到初始点(1号)的距离，前缀和
	vec.resize(n + 2);
	for (int i = 1; i <= n; i++) {
		int tmp;
		scanf("%d", &tmp);
		sum += tmp;
		vec[i + 1] = sum;  // 因为是记录到第一个点的距离，就从第二个点开始，所以下标为 i + 1
	}
	scanf("%d", &m);
	int a, b, t;
	for (int i = 0; i < m; i++) {
		scanf("%d %d", &a, &b);
		if (a > b) swap(a, b);
		t = vec[b] - vec[a];
		printf("%d\n", min(t, sum - t));
	}
	return 0;
}
```

**可以学习的:**

1、涉及到子序列求和的问题，输入时存成前缀和的形式是最省时的，前缀和两两相减即可得到连续子序列的和

### 1047 Student List for Course

题目大意：给出选课人数和课程数目，然后再给出每个人的选课情况，请针对每门课程输出选课人数以及所有选该课的学生姓名，按照字典序

解题思路：用map最后一个测试点会超时。建立int的二维数组，course\[i][j] = k表示第i号课程上的第j个人的姓名编号为k，也就是说course[i]是一个课程的学生信息列表；学生姓名用字符数组name\[i][j]存储，name[i]即为一个学生的姓名；k是上这个课的学生的姓名所在的字符数组name\[i][j]的i下标；注意：strcmp返回的不一定是-1，0，1这几个数字，要返回bool变量还需要在后面添加strcmp是大于0还是小于0

核心代码

```C++
bool cmp1(int a, int b) {
	return strcmp(name[a], name[b]) < 0;
}
int main() {
	int n, k;
	scanf("%d %d", &n, &k);
	for (int i = 0; i < n; i++) {
		int cnt, temp;
		scanf("%s %d", name[i], &cnt);
		for (int j = 0; j < cnt; j++) {
			scanf("%d", &temp);
			course[temp].push_back(i);  // 编号为temp的课上有编号为i的学生
		}
	}
	for (int i = 1; i <= k; i++) {
		printf("%d %d\n", i, course[i].size());
		sort(course[i].begin(), course[i].end(), cmp1);
		for (int j = 0; j < course[i].size(); j++) {
			printf("%s\n", name[course[i][j]]);
		}
	}
	return 0;
}
```

**可以学习的：**

1、map有时候会超时，还得回到原始的方法，用数组

### 1048 Find Coins

题目大意：给出n个正整数和一个正整数m，问n个数字中是否存在一对数字a和b(a <= b),使a+b=m成立。如果有多个，输出a最小的那一对

解题思路1：先对n个正整数从小到大排序；遍历排过序的数组，对每一个数vec[i]，用二分查找往后面去找m - vec[i]；由于用了二分查找，速度也不慢，12ms

解题思路2：散列表；建立数组a记录每个硬币面值数字出现的次数，而面值范围从1到500，这样查找范围就在500内，较快，9ms。

核心代码1

```C++
int main() {
	int n, m;
	int vec[100005];
	scanf("%d %d", &n, &m);
	for (int i = 0; i < n; i++) 
		scanf("%d", &vec[i]);
	sort(vec, vec + n);
	for (int i = 0; i < n - 1; i++) {
		int j = lower_bound(vec + i + 1, vec + n, m - vec[i]) - vec;
		if (vec[i] + vec[j] == m) {
			printf("%d %d", vec[i], vec[j]);
			return 0;
		}
	}
	printf("No Solution");
	return 0;
}
```

核心代码2

```C++
int a[501];  // 记录每个数字出现的次数
int main() {
	int n, m, temp;
	scanf("%d %d", &n, &m);
	for (int i = 0; i < n; i++) {
		scanf("%d", &temp);
		a[temp]++;  // 记录每个面值为temp的硬币的个数
	}
	for (int i = 0; i < 501; i++) {
		if (a[i]) {
			a[i]--;
			if (m > i && a[m - i]) {
				printf("%d %d", i, m - i);
				return 0;
			}
		}
	}
	printf("No Solution");
	return 0;
}
```

**可以学习的：**

1、二分查找的函数，upper_bound(a, b, c)在范围a-b之间找大于c的数、lower_bound(a, b, c)在范围a-b之间找大于等于c的数

2、范围较小的题，一般是小于1e4，可以考虑用散列表

### 1049 Counting Ones

题目大意：给出一个数字n，求1~n的所有数字里面出现1的个数

解题思路：数学问题 or 规律问题？考虑每一个数位在1~n会出现的次数，而这个次数是可以推导出公式来计算的，个位上会出现1的次数为 (n - 1) / 10 + 1；十位上会出现1的次数为 [(n - 10) / 100 + 1] * 10 - if (n % 100 ∈ [10, 19]) [10 - (n + 1) % 10]；百位及以后的数位，与十位类似。将以上各个数位的次数累加即可。

核心代码

```C++
int main() {
	int n, base = 10, sum = 0;
	scanf("%d", &n);
	sum += (n - 1) / 10 + 1;  // 个位上1会出现的次数
	while (n >= base) {
		sum += ((n - base) / (10 * base) + 1) * base;
		if (n % (10 * base) <= (base * 2 - 1) && n % (10 * base) >= base) {
			sum -= (base - (n + 1) % base);
		}
		base *= 10;
	}
	printf("%d", sum);
	return 0;
}
```

**可以学习的：**

1、几乎没有，这种是特殊题，只能冷静分析，剩下就自求多福了

### 1050 String Subtraction

题目大意：给出两个字符串，在第一个字符串中删除第二个字符串中出现过的所有字符并输出

解题思路：用flag[256]数组标记str2出现过的字符为true，输出str1的时候根据flag[str1[i]]是否为true，如果是true就不输出

核心代码

```C++
char s1[10005], s2[10005];
int main() {
	cin.getline(s1, 10005);
	cin.getline(s2, 10005);
	int len1 = strlen(s1), len2 = strlen(s2);
	bool flag[256] = { false };
	for (int i = 0; i < len2; i++)
		flag[s2[i]] = true;  // 标记需要剔除的字符
	for (int i = 0; i < len1; i++)
		if (!flag[s1[i]])  // 只输出不需要剔除的字符
			printf("%c", s1[i]);
	return 0;
}
```

**可以学习的：**

1、哈希散列

### 1051 Pop Sequence

题目大意：有个容量限制为m的栈，分别把1，2，3，...，n入栈，给出k组出栈顺序，问这些出栈顺序是否可能

解题思路：进行k次入栈出栈模拟。先把可能的输出序列接收进数组v，然后按照1~n的顺序，每次压入一个数字，作2次判断，判断有没有超过栈的容量m，超过就直接break；没超过，再判断当前栈顶元素是否等于数组v中的元素，此过程用current来标记位置，相等就一直while，current++，出栈；若不相等，则继续按顺序压入数字；最后根据current的值是否等于n+1来输出YES或NO

核心代码

```C++
int main() {
	int m, n, k;
	scanf("%d %d %d", &m, &n, &k);
	for (int i = 0; i < k; i++) {
		bool flag = false;
		stack<int> s;
		vector<int> v(n + 1);
		for (int j = 1; j <= n; j++)
			scanf("%d", &v[j]);
		int current = 1;  // 用于标记刚输入的可能序列的位置
		for (int j = 1; j <= n; j++) {
			s.push(j);
			if (s.size() > m) break;
			while (!s.empty() && s.top() == v[current]) {
				s.pop();  // 栈顶与输出序列相等，则弹出栈顶
				current++;  // 去判断下一个位置
			}
		}
		if (current == n + 1) flag = true;
		if (flag) printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
```

**可以学习的：**

1、栈stack的基本使用，push()、pop()、top()函数的使用

2、栈模拟

### 1052 Linked List Sorting

题目大意：给出一个链表，将链表排序，然后把链表上的结点按照data值的从小到大顺序输出

解题思路：建立结构体数组，按照从首地址开始的顺序（直到-1）遍历一遍整个链表，将在链表中的结点的flag标记为true，并且统计在链表里的结点的个数cnt，因为有的结点根本不在链表中；然后将整个结构体数组进行排序，如果节点的flag为false就把他们移动到后面（即：reuturn a.flag > b.flag），最后只输出前cnt个节点的信息，也即排好序的那条链表

核心代码

```C++
struct NODE {
	int address, key, next;
	bool flag;
} node[100001];
bool cmp1(NODE a, NODE b) {
	if (!a.flag || !b.flag)  // 有任何一方不在链表内
		return a.flag > b.flag;  // 把false放到后面去
	else
		return a.key < b.key;
}

int main() {
	int n, cnt = 0, s, a, b, c;
	scanf("%d %d", &n, &s);
	for (int i = 0; i < n; i++) {
		scanf("%d %d %d", &a, &b, &c);
		node[a] = { a, b, c, false };  // 有些节点不在链表里面
	}
	for (int i = s; i != -1; i = node[i].next) {  // 从起始节点遍历一次链表
		node[i].flag = true;  // 在链表里的标记为true
		cnt++;  // 并统计链表长度
	}
	if (cnt == 0) {  // 链表为空的情况
		printf("0 -1");
	}
	else {
		sort(node, node + 100001, cmp1);
		printf("%d %05d\n", cnt, node[0].address);
		for (int i = 0; i < cnt - 1; i++) 
			printf("%05d %d %05d\n", node[i].address, node[i].key, node[i + 1].address);
		printf("%05d %d -1", node[cnt - 1].address, node[cnt - 1].key);
	}
	return 0;
}
```

**可以学习的：**

1、链表题的基本思路：用结构体存节点；开结构体数组存链表；需要用到完整的链表时，用start和next遍历一次即可，并且，这种需要一般不会太多，也就是说，不需要过于担心链表存在数组里带来的不连贯性

2、当题目给出n个节点时，这条链表里，可能不一定有n个节点；因为一些节点可能根本不在链表里

3、若数组长度大于有效元素数量时，即数组里面有些是没用的，这时需要进行排序，cmp()函数里得分情况返回bool值

### 1053 Path of Equal Weight

题目大意：给出树的结构和权值，找从根结点到叶子结点的路径上的权值相加之和等于给定目标数的路径，并且从大到小输出路径

解题思路：深度优先遍历。记录所有情况的路径，最后对路径按字典序大小排序。

核心代码

```C++
const int maxn = 110;  // 这题最多100个节点
struct NODE {
	int weight;
	vector<int> child;
} node[maxn];
int n, m, s;
vector<int> path;
vector<vector<int>> ans;  // 存放所有路径
void dfs(int index, vector<int> path, int sum) {
	if (sum > s) return;
	if (sum == s) {
		if (node[index].child.size() != 0) return;  // 还有孩子，即未到达叶子节点
		ans.push_back(path);
		return;
	}
	for (int i = 0; i < node[index].child.size(); i++) {
		int child = node[index].child[i];  // 遍历当前节点的孩子
		path.push_back(node[child].weight);  // 加入当前节点权重
		dfs(child, path, sum + node[child].weight);  // 去下一层dfs判断是否等于目标值s
		path.pop_back();  // 若大于或等于，就会回来这一层，将刚加入的节点再去掉，说明这个节点对这条路径没用
	}
}
int main() {
	scanf("%d %d %d", &n, &m, &s);
	for (int i = 0; i < n; i++) {
		scanf("%d", &node[i].weight);
	}
	int id, k, child;
	for (int i = 0; i < m; i++) {
		scanf("%d %d", &id, &k);
		for (int j = 0; j < k; j++) {
			scanf("%d", &child);
			node[id].child.push_back(child);
		}
	}  // 至此完成输入
	path.push_back(node[0].weight);  // 每条路径肯定是从根节点开始的
	dfs(0, path, node[0].weight);  // 现处节点编号、已有路径、路过节点权重之和
	sort(ans.begin(), ans.end(), greater<vector<int>>());  // greater()函数，从大到小排序
	for (int i = 0; i < ans.size(); i++) {
		printf("%d", ans[i][0]);
		for (int j = 1; j < ans[i].size(); j++) {
			printf(" %d", ans[i][j]);
		}
		printf("\n");
	}
	return 0;
}
```

**可以学习的：**

1、sort的greater()函数的使用

2、带权重的树的遍历，需要使用结构体来存每个节点的信息

### 1054 The Dominant Color

题目大意：选取主色调，就是M列N行的矩阵里面出现次数多余一半的那个数字

解题思路：使用map去做颜色与其次数的映射，即pic[i] = j表示i元素在矩阵中出现了j次，在输入的同时比较pic当前的值是否已经超过半数

**可以学习的：**

1、map的使用

### 1055 The World's Richest

题目大意：给出n个人的姓名，年龄和资产，然后进行k次查询，要求每次查询输出在年龄区间内的财富值的从大到小的前m个人的信息。如果财富值相同就就先输出年龄小的，如果年龄相同就把名字按照字典序排序输出

解题思路：首先读入数据后，对所有数据进行一次sort排序（按照资产降序>年龄升序>姓名字典序）；遍历排序后的数组，将人的信息存入vector数组v，进行剪枝，遍历时统计各个年龄段的人的人数，如果某一年龄人数超过100，则不需要再放入（因为最多输出就是100）；之后读入查询信息，每读入一条，遍历A，输出最先查找到的M个人结束运行，或输出所有符合要求的不足M条的信息。

核心代码

```C++
struct node {
	char name[10];
	int age, money;
};
int cmp1(node a, node b) {
	if (a.money != b.money)
		return a.money > b.money;  // 资产降序
	else if (a.age != b.age)
		return a.age < b.age;  // 年龄升序
	else
		return (strcmp(a.name, b.name) < 0);  // 字典序升序
}
int main() {
	int n, k, num, amin, amax;
	scanf("%d %d", &n, &k);
	vector<node> vt(n), v;
	vector<int> book(205, 0);
	for (int i = 0; i < n; i++)
		scanf("%s %d %d", vt[i].name, &vt[i].age, &vt[i].money);

	sort(vt.begin(), vt.end(), cmp1);
	for (int i = 0; i < n; i++)
		if (book[vt[i].age] < 100) {
			v.push_back(vt[i]);  // 只将每个年龄的资产前100人放入新数组中，相当于筛选了一遍
			book[vt[i].age]++;
		}
	for (int i = 0; i < k; i++) {
		scanf("%d %d %d", &num, &amin, &amax);
		vector<node> t;
		for (int j = 0; j < v.size(); j++)
			if (v[j].age >= amin && v[j].age <= amax)
				t.push_back(v[j]);
		printf("Case #%d:\n", i + 1);
		int flag = 0;
		for (int j = 0; j < num && j < t.size(); j++) {
			printf("%s %d %d\n", t[j].name, t[j].age, t[j].money);
			flag = 1;
		}
		if (flag == 0) printf("None\n");
	}
	return 0;
}
```

**可以学习的：**

1、有些排序是可以进行剪枝的，不剪，可能会超时

### 1056 Mice and Rice

题目大意：n为老鼠的数量，每组最多k个老鼠。先给出n个老鼠的重量（这些重量是从1到n的编号给出的），再给出老鼠的初始顺序（1到n的排列）。每k个老鼠分为一组，对于每组老鼠，选出最重的那个，晋级下一轮比赛，然后依次再以k个老鼠一组分类，然后选出重量最大的。。。直到只剩下一只老鼠，排名为1。输出为老鼠的排名，这个排名需要按照从1到n的编号给出

解题思路：用队列存储老鼠的编号，一轮完了可以紧接下一轮；去模拟这个比赛的过程就行了，虽然并不简单

核心代码

```C++
int n, k, group, lastnum, maxn = -1, maxid, temp;
int main() {
	scanf("%d %d", &n, &k);  // 一共n个人，一组k个人
	vector<int> weight(n), rank(n);
	queue<int> mice;
	for (int i = 0; i < n; i++)
		scanf("%d", &weight[i]);
	for (int i = 0; i < n; i++) {
		scanf("%d", &temp);
		mice.push(temp);
	}
	lastnum = n;
	while (lastnum > 1) {
		group = lastnum / k + (lastnum % k == 0 ? 0 : 1);  // 能分成的组数
		for (int i = 1; i <= lastnum; i++) {
			temp = mice.front();
			if (maxn < weight[temp]) {
				maxn = weight[temp];
				maxid = temp;
			}
			rank[temp] = group + 1;   // 可以先认为这一次所有人的名次都是未晋级的名次，下一轮会更新那些晋级的人的名次
			mice.pop();  // 不断弹出已经决出胜负的人
			if (i % k == 0 || i == lastnum) {
				mice.push(maxid);  // 将获胜的人继续压入队列
				maxn = -1;  // 每一组找出一个最大值，然后重置最大值为-1，继续找下一组
			}
		}
		lastnum = mice.size();
	}
	rank[mice.front()] = 1;  // 最后剩下的那个就是第一名
	printf("%d", rank[0]);
	for (int i = 1; i < n; i++)
		printf(" %d", rank[i]);
	return 0;
}
```

**可以学习的：**

1、队列的基本概念，及其基本的使用函数，pop()、push()、size()

2、有些题目是尼玛真的难懂，唯一的建议是多读几遍题

### 1057 Stack

题目大意：现请你实现一种特殊的堆栈，它多了一种操作叫“查中值”，即返回堆栈中所有元素的中值。对于N个元素，若N是偶数，则中值定义为第N/2个最小元；若N是奇数，则中值定义为第(N+1)/2个最小元

解题思路：用排序查询的方法会超时。利用**树状数组**，查找中位数；开一个足够大的数组c，初始化为0， 若值x在数组中，我们则需要更新c[x]位置的值，令其+1，同时修改受影响的所有位置的值，要x值离开了数组，同样要更新c[x]位置的值；当查询x在序列中的升序排名（第几小）时，返回的是c[x]位置的前缀和。

核心代码

```C++
# define lowbit(i) ((i) & (-i))
const int maxn = 100010;
int c[maxn];  // 树状数组；哈希散列，下标是输入的数，数组里对应存的是数的个数
stack<int> s;
void update(int x, int v) {  // 更新树状数组c，x是要修改的数，v是1代表加入了x，v是-1代表除去了x
	for (int i = x; i < maxn; i += lowbit(i))  // 用这个for去遍历数组后，自然就形成了一个树状数组
		c[i] += v;
}
int getsum(int x) {  // 统计小于等于x的数的个数
	int sum = 0;
	for (int i = x; i >= 1; i -= lowbit(i))  // 这个树状数组的好处就是可以“跳着”去找相差很大的数
		sum += c[i];
	return sum;
}
void PeekMedian() {
	int left = 1, right = maxn, mid, k = (s.size() + 1) / 2;  // 去找这第k小的数，而比一半数小的数就是中位数
	while (left < right) {  // 二分查找
		mid = (left + right) / 2;
		if (getsum(mid) >= k)
			right = mid;
		else
			left = mid + 1;
	}
	printf("%d\n", left);
	return;
}
```

**可以学习的：**

1、树状数组的基本概念，及其实现与应用。上面代码的第一个函数update()实现了树状数组的值修改功能，特别是那个for循环的写法，是实现树状数组的核心；树状数组的主要意义是在有动态修改的情况下，实现了logn级别的查找复杂度

2、二分查找，超时后，第一反应要是，看看普通的暴力for能不能改成二分的形式

