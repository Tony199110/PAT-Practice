### 1003 Emergency

题目大意：n个城市m条路，每个城市有救援小组(即点权)，所有的边的边权已知。给定起点和终点，求从起点到终点的最短路径条数以及最短路径上的救援小组数目之和。如果有多条就输出点权（城市救援小组数目）最大的那个

解题思路：用Dijkstra算法，求出从起始点出发到各个节点的最短路径长度、最短路径条数、最大路过的点权之和；涉及到三个与目的相关的需要不断更新的数组，dis[i]表示从出发点到i结点最短路径的路径长度，num[i]表示从出发点到i结点最短路径的条数，w[i]表示从出发点到i点救援队的数目之和；

核心代码

```C++
int n, m, c1, c2;
int e[510][510], weight[510], dis[510], num[510], w[510];
bool visit[510];
const int inf = 99999999;
int main() {
	scanf("%d %d %d %d", &n, &m, &c1, &c2);
	for (int i = 0; i < n; i++) scanf("%d", &weight[i]);
	fill(e[0], e[0] + 510 * 510, inf);
	fill(dis, dis + 510, inf);
	int a, b, c;
	for (int i = 0; i < m; i++) {
		scanf("%d %d %d", &a, &b, &c);
		e[a][b] = e[b][a] = c;
	}
	dis[c1] = 0;  // dis[i]表示从出发点到i节点最短路径的路径长度
	w[c1] = weight[c1];  // w[i]表示从出发点到i节点，点权之和
	num[c1] = 1;  // num[i]表示从出发点到i节点最短路径的条数
	for (int i = 0; i < n; i++) {
		int u = -1, minn = inf;
		for (int j = 0; j < n; j++) {  // 这个for的目的是在每一i下，选出一个节点u，去更新与u相邻的那些邻居节点v距离起始节点的长度
			if (visit[j] == false && dis[j] < minn) {
				u = j;
				minn = dis[j];  // 找出从出发点到节点j的最短路径，记下其长度
			}
		}
		if (u == -1) break;
		visit[u] = true;  // 每轮i，只将一个节点的访问状态置为“已访问”
		for (int v = 0; v < n; v++) {
			if (visit[v] == false && e[u][v] != inf) {  // v节点未被访问过且可达
				if (dis[u] + e[u][v] < dis[v]) {  // 如果新的路径更短，则更新
					dis[v] = dis[u] + e[u][v];  // 更新最短路径长度
					num[v] = num[u];  // 更新最短路径的条数
					w[v] = w[u] + weight[v];  // 更新最短路径路过的点权之和
				}
				else if (dis[u] + e[u][v] == dis[v]) {
					num[v] = num[v] + num[u];  // 若有多条路径，增加最短路径的条数
					if (w[u] + weight[v] > w[v]) {  // 若有多条最短路径，找点权之和最大
						w[v] = w[u] + weight[v];
					}
				}
			}
		}
	}  // 至此，已经找到了从c1出发到各个节点的最短路径长度、最短路径条数、最大路过的点权之和
	printf("%d %d", num[c2], w[c2]);  // 输出需要的c2终点
	return 0;
}
```

**可以学习的**

1、Dijkstra算法的基本思想：固定了一个顶点作为源结点然后找到该顶点到图中所有其它结点的最短路径，产生一个最短路径树。本算法每次取出未访问结点中距离最小的，用该结点更新其他结点的距离。

2、Dijkstra算法的扩展，在计算最短路径时，也可以同时计算最短路径条数、最短路径路过的点权重之和

### 1004 Counting Leaves

题目大意：给定一棵树，给的形式是：告知节点总数N、非叶子节点数量M；M行中每一行，告知非叶子节点的编号、其儿子的数量以及儿子的编号。目的是求出树的每个高度 中叶子节点的数量。

解题思路：**用dfs，用二维数组保存每一个有孩子结点的结点以及他们的孩子结点，从根结点开始遍历，直到遇到叶子结点，就将当前层数depth的book[depth]++；标记第depth层拥有的叶子结点数，最后输出**

核心代码

```C++
vector<int> v[100];  // 容器v存储树
int book[100], maxdepth = -1;  // book存答案，即每一层叶子节点的数量

void dfs(int index, int depth) {
    if (v[index].size() == 0) {  // 若当前节点没有孩子，则当前层叶子节点数量加1
        book[depth]++;
        maxdepth = max(maxdepth, depth);
        return;
    }
    // 若当前节点有孩子，则遍历其孩子节点
    for (int i = 0; i < v[index].size(); i++) {
        dfs(v[index][i], depth + 1);
    }
}
```

**可以学习的**

1、邻接链表存二维数组可节省空间；

2、使用dfs的基本思想，对树进行操作

### 1005 Spell It Right

题目大意：给一个非负整数N，N可以很大，$10^{100}$。目的是计算N的每个数字的和，并使用英文输出和的每个数字。

解题思路：使用string存储N，利用（a[i] - '0'）计算每一位的和sum；将sum转化为string；输出。

**可以学习的**

1、string的使用，常用函数to_string()，记得包括头文件；

2、char减'0'得到整型数的操作

### 1006 Sign In and Sign Out

题目大意：给出n个人的id、签到时间、签出时间，目的是求最早签到的人的ID和最晚签出的人的ID。

解题思路：将时间都转化为以秒数，ID存入string，最早和最晚的时间分别保存在变量minn和maxn中，并同时更新当前最早和最晚的人的ID；输出。

**可以学习的**

1、格式化输入时，如时间，使用scanf是非常好的选择；

2、最大最小值的初始化，可以使用INT32_MIN、INT32_MAX

### 1007 Maximum Subsequence Sum

题目大意： 给出一个长度为n的整数序列，目的是求最大连续子序列和，输出最大的和以及这个子序列的开始值和结束值。如果所有数都小于0，那么认为最大的和为0，并且输出首尾元素。

解题思路：设，sum为要求的最大和，temp为临时最大和，leftindex和rightindex为所求的子序列的开始和结束的下标，tempindex为标记left的临时下标。

让temp = temp + v[i] ，判断，当temp比sum大，就更新sum的值、leftindex的值、rightindex的值；当temp < 0，那么后面不管来什么值，都应该舍弃temp < 0前面的内容，因为负数只可能拉低总和，不可能增加总和，所以直接舍弃。

舍弃后，令temp=0，重新开始算总和，并且同时更新left的临时值tempindex为i+1，即下一个位置的下标。

因为对于所有值都为负数的情况要输出0、第一个值、最后一个值，所以在输入（遍历）的时候用flag判断是不是所有的数字都小于0，如果是，则需要在输出时作特殊处理。这里没有用flag，取而代之的是为leftindex和rightindex赋初值时，直接赋为0和n-1，这样若temp一直小于0，leftindex和rightindex不会更新，输出时也是正确的。

核心代码

```C++
int main() {
	int n;
	scanf("%d", &n);
	vector<int> v(n);
	int leftindex = 0, rightindex = n - 1, sum = -1, temp = 0, tempindex = 0;
	for (int i = 0; i < n; i++) {
		scanf("%d", &v[i]);  // 边输入，边操作，O(n)的复杂度
		temp = temp + v[i];  // 临时的子序列总和
		if (temp < 0) {  // 若当前总和小于0，使总和重新为0，下标为下一个位置
			temp = 0;
			tempindex = i + 1;
		}
		else if (temp > sum) {  // 若当前总和变大了，则更新最大总和、左右下标
			sum = temp;
			leftindex = tempindex;
			rightindex = i;
		}
	}
	if (sum < 0) sum = 0;
	printf("%d %d %d", sum, v[leftindex], v[rightindex]);
	return 0;
}
```

**可以学习的**

1、最长子序列和的写法

2、当算法时间复杂度是O(n)，且一组输入有n个数时，可以边输入，边操作

### 1008 Elevator

题目大意：电梯初始停在0层，告知上一层需6s，下一层需4s，停一次需5s。现给出一个电梯停的序列，目的是求出走完所有给出楼层需要多少时间。

解题思路：累计计算，输出。

**可以学习的**

1、当算法时间复杂度是O(n)，且一组输入有n个数时，可以边输入，边操作

### 1009 Product of Polynomials

题目大意：求两个多项式的乘积

解题思路：float类型的arr数组保存第一组多项式，ans数组保存答案，以幂次为数组下标存储；输入第二组多项式时，一边输入，一边直接计算结果，存入ans数组。最后按幂次从高到低输出。

核心代码

```C++
int main() {
	int n1, n2, a, cnt = 0;
	float b, arr[1001] = { 0.0 }, ans[2001] = { 0.0 };
	scanf("%d", &n1);
	for (int i = 0; i < n1; i++) {
		scanf("%d %f", &a, &b);
		arr[a] = b;
	}
	scanf("%d", &n2);
	for (int i = 0; i < n2; i++) {
		scanf("%d %f", &a, &b);
		for (int j = 0; j < 1001; j++) {
			ans[j + a] += arr[j] * b;  // 相乘得到的项次数更高，故+a
		}
	}
	for (int i = 2000; i >= 0; i--) {
		if (ans[i] != 0.0) cnt++;
	}
	cout << cnt;
	for (int i = 2000; i >= 0; i--) {
		if (ans[i] != 0.0) {
			// cout << " " << i << " " << fixed << setprecision(1) << ans[i];
			printf(" %d %.1f", i, ans[i]);
		}
	}
	return 0;
}
```

**可以学习的**

1、使用 printf 或 cout 进行格式化输出；

2、与多项式相关的题，如多项式相加、多项式相乘，以幂次为数组下标存储是一个非常不错的方式

### 1010 Radix

题目大意：给出两个长度不超过10的字符串，告知其中一个是几进制。目的是求另一个数会在几进制下与这个数相等，输出进制数即可；若不存在可能相等，则输出Impossible。

解题思路：先将知道是几进制的数转化为10进制下的数值，存储在long long中；然后用二分查找遍历进制数，并将另一个数也转化为10进制，对比都在10进制下的两个数，直到二者相等或找不到；输出。

核心代码

```C++
long long convert(string n, long long radix) { // 将数值n按照radix进制转化为10进制表示的数
	long long sum = 0;  // 由于返回值是long long，当radix较大时容易溢出，变成负数
	int temp = 0;
	for (int i = 0; i < n.length(); i++) {
		temp = isdigit(n[i]) ? n[i] - '0' : n[i] - 'a' + 10;  // 分两段考虑字符转数值
		sum += temp * pow(radix, n.length() - i - 1);
	}
	/*
	int index = 0;  // 使用string中的rbegin()和rend()函数来反向遍历字符串
	for (auto it = n.rbegin(); it != n.rend(); it++){
		temp = isdigit(*it) ? *it - '0' : *it - 'a' + 10;
		sum += temp * pow(radix, index++);
	}
	*/
	return sum;
}
long long find_radix(string n, long long num) { // 找到令两个数值相等的进制数
	char it = *max_element(n.begin(), n.end());
	long long low = (isdigit(it) ? it - '0' : it - 'a' + 10) + 1;
	long long high = max(low, num);  // low有可能大于num，例如n为0，num为0
	while (low <= high) {
		long long mid = (low + high) / 2;  // 二分查找
		long long t = convert(n, mid);
		if (t < 0 || t > num) { // 将n转换为十进制数时，由于num可以较大(10^18),convert后long long可能会溢出，变成负数
			high = mid - 1;
		}
		else if (t == num) return mid;
		else low = mid + 1;
	}
	return -1;
}
```

**可以学习的**

1、使用二分查找加快遍历速度，其写法；

2、使用string中的rbegin()和rend()函数来反向遍历字符串；

3、在合适的时候使用三目运算符，有助于精简代码

### 1011 World Cup Betting

题目大意：赌球，给出三场比赛赢、平、输的赔率，选取每场比赛中赔率最大的数以及对应的赢、平、输结果；按照公式计算出利润；输出

解题思路：依次读入每场比赛赢、平、输的赔率，求最大值及其下标，输出下标，ans累乘；按照公式求出利润值；输出

**可以学习的**

1、最普通的求最大值及其下标的写法

### 1012 The Best Rank

题目大意：给出n个学生的3门成绩，平均分可自己算；那么每个学生有4个排名；现有m个学生来查询自己的最好排名以及是哪个科目最好，若4个名次中的某些相同，则按A>C>M>E的优先级输出；若查询的学生id不存在，则输出N/A

解题思路：使用结构体stu存储学生的id、四门成绩、四门排名、最好排名对应的科目下标；

处理同分数情况的方式，采用1、1、3、4的方式，而不是1、1、2、3；

从示例中看，平均分是四舍五入得出的，故求平均分时，需+0.5再取整；

存储四门成绩时，考虑到优先级是A>C>M>E，故按照这个顺序存储，按照这个顺序排序，可以简化逻辑；

处理查询时学生是否存在的问题，定义exist数组，以id为其下标，为0就说明不存在某学生，不为0还可以映射为stu的下标，一举两得。

核心代码

```C++
struct node {
	int id, best;  // best存rank最小的下标
	int score[4], rank[4];
}stu[2001];

int exist[1000000] = { 0 }, flag = -1;
bool cmp1(node a, node b) return a.score[flag] > b.score[flag];
int main() {
	int n, m, id;
	cin >> n >> m;
	for (int i = 0; i < n; i++) {
		scanf("%d %d %d %d", &stu[i].id, &stu[i].score[1], &stu[i].score[2], &stu[i].score[3]);
		stu[i].score[0] = (stu[i].score[1] + stu[i].score[2] + stu[i].score[3]) / 3.0 + 0.5;
	}
	for (flag = 0; flag <= 3; flag++) {
		sort(stu, stu + n, cmp1);  // 从大到小排，并且通过flag循环将A、C、M、E均排序
		stu[0].rank[flag] = 1;
		for (int i = 1; i < n; i++) {  // 求出名次rank
			stu[i].rank[flag] = i + 1;
			if (stu[i].score[flag] == stu[i - 1].score[flag]) {  // 如果同分
				stu[i].rank[flag] = stu[i - 1].rank[flag];  // 同分则rank取相同，取最靠前那个
			}
		}
	}
	for (int i = 0; i < n; i++) {
		exist[stu[i].id] = i + 1;  // 在sort之后再给exist赋值，才能以其值作下标访问stu
		stu[i].best = 0;
		int minn = stu[i].rank[0]; // 求出每个学生的最佳rank，即求最小值
		for (int j = 1; j <= 3; j++) {
			if (stu[i].rank[j] < minn) {
				minn = stu[i].rank[j];
				stu[i].best = j;
			}
		}
	}
	char c[5] = { "ACME" };
	for (int i = 0; i < m; i++) {
		cin >> id;
		int temp = exist[id]; // 以id为下标，构造出了一一映射的关系
		if (temp) {
			int best = stu[temp - 1].best;
			printf("%d %c\n", stu[temp - 1].rank[best], c[best]);
		}
		else printf("N/A\n");
	}
	return 0;
}
```

**可以学习的**

1、结构体的使用，对结构体sort需要自己构造cmp函数；

2、四舍五入的方式，即+0.5再取整；

3、涉及到查询id是否存在的问题时，定义一个以id为下标、index为值的exist数组，是不错的方案；

4、若存储几个同等地位的数时，题目有给某种优先级顺序，那么按照这个顺序来存是值得考虑的方式

### 1013 Battle Over Cities

题目大意：给出n个城市之间有相互连接的m条道路，当删除其中的一个城市及与其连接的道路时，求出需要另外添加至少多少条路线才能让剩余的所有城市重新连通

解题思路：将问题抽象出来，求添加最少的道路数，就是连通分量数减去1，因为当a个互相分立的连通分量需要变为连通图的时候，只需要添加a-1条道路，就能让他们相连。所以这道题就是求：去除了某个结点之后其他的图所拥有的连通分量数

核心代码

```C++
int v[1001][1001], n;
bool visit[1001];
void dfs(int node) {
	visit[node] = true;  // 将访问过的节点置为true
	for (int i = 1; i <= n; i++)  // 遍历所有节点找强连通图，只能这么做？恐怕是的
		if (visit[i] == false && v[node][i] == 1)  // 若当前节点还未被访问，且i节点与当前节点是相邻的
			dfs(i);  // 说明i节点与当前节点是连通的，则深度搜索i节点
}
int main() {
	int m, k, a, b;
	cin >> n >> m >> k;
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		v[a][b] = v[b][a] = 1;  // 邻接矩阵存图的连接关系
	}
	for (int i = 0; i < k; i++) {
		cin >> a;
		fill(visit, visit + 1001, false);  // 每做一个节点的强连通分量，需要重置整张图为未访问状态
		int cnt = 0;
		visit[a] = true;  // 被去掉的节点，只需将其的访问状态置为“已访问”即可
		for (int j = 1; j <= n; j++) {
			if (visit[j] == false) {
				dfs(j);  // 这里的一个dfs就可以将一张强连通分量图置为“已访问”状态
				cnt++;  // 强连通分量的个数加一
			}
		}
		cout << cnt - 1 << endl;  // 强连通分量的个数 - 1就是需要增加的边的条数，因为一个强连通分量就代表着一张独立的图
	}
	return 0;
}
```

**可以学习的**

1、遍历图的方法，设置visit数组，记录图中节点的访问状态，dfs去遍历；

2、fill函数，用来填充容器

### 1014 Waiting in Line

题目大意：有n个窗口，每个窗口最多可以排队m人，多余的人在黄线外，不参与排队；现有k位客户需要服务，给出每位客户办业务的所需时间，单位为分钟；银行早上8点开始提供服务，客户会优先选择队伍短的进行排队，若有2支或以上的队伍长度相同，则客户选择窗口数最小的；现有q位用户在等待，包括黄线内和黄线外，目的是求出这q位用户服务结束的时间，格式为HH:MM；若在17:00后仍没有得到服务，则银行关门，输出sorry。

解题思路：设立结构体，poptime代表队首的人出队的时间，endtime代表队尾的人出队的时间。poptime是为了让黄线外的人可以计算出哪一个队列先空出人来（poptime最小的那个先有人服务完毕），endtime是为了入队后加上自己本身的服务所需时间可以计算出自己多久才能被服务完毕。且前一个人的endtime可以得知自己是不是需要被Sorry（如果前一个人服务结束时间超过17:00，自己当前入队的人就是sorry）。还有一个queue表示所有当前该窗口的排队队列。
对于前m\*n个人，也就是排的下的情况下，所有人依次到窗口前面排队。对于m\*n之后的人，当前人选择poptime最短的入队，让队伍的第一个人出列），如果前面一个人导致的endtime超过17点就标记自己的sorry为true。

计算时间的时候按照分钟计算，最后再考虑08点开始和转换为小时分钟的形式会比较简便

核心代码

```C++
struct node {
	int poptime, endtime;  // poptime代表队首的人出队的时间，endtime代表队尾的人出队的时间
	queue<int> q;  // 表示当前窗口的排队队列
};
int main() {
	int n, m, k, q, index = 1;  // index是遍历k个客户服务时间用的，贯穿全文
	scanf("%d %d %d %d", &n, &m, &k, &q);
	vector<int> time(k + 1), result(k + 1);  // 数组不能用变量k声明，而vector可以
	for (int i = 1; i <= k; i++) scanf("%d", &time[i]);
	vector<node> window(n + 1); // 为每个窗口都维持一个队列
	vector<bool> sorry(k + 1, false);  // 
	for (int i = 1; i <= m; i++) {  // 遍历窗口队列容量，即再装第二排，
		for (int j = 1; j <= n; j++) {  // 遍历窗口，即先装第一排，
			if (index <= k) {  // 用于截断k<n*m的情况，k>n*m时，这个if会一直成立
				window[j].q.push(time[index]);  // 初始化，将客户一个个装进队列里
				if (window[j].endtime >= (17 - 8) * 60) 
					sorry[index] = true;  // 若当前该队列队尾出队的时刻超过了17点，则新入队的人只能sorry
				window[j].endtime += time[index];  // 每入队一个人就要更新当前队列的endtime
				if (i == 1) window[j].poptime = window[j].endtime;
				result[index] = window[j].endtime;
				index++;
			}
		}
	}  // 至此，初始化完成，即将黄线内的人塞满了
	while (index <= k) {  // 若黄线外没人，则这个while就不用进去
		int tempmin = window[1].poptime, tempwindow = 1;
		for (int i = 2; i <= n; i++) 
			if (window[i].poptime < tempmin) {  // 找队首最快结束服务的各窗口
				tempmin = window[i].poptime;
				tempwindow = i;
			}
		window[tempwindow].q.pop();  // 找到最快结束服务的客户后，让他出队
		window[tempwindow].q.push(time[index]);  // 出队后，让黄线外的下一个客户进入这个队列
		window[tempwindow].poptime += window[tempwindow].q.front();
		if (window[tempwindow].endtime >= (17 - 8) * 60) sorry[index] = true;
		window[tempwindow].endtime += time[index];
		result[index] = window[tempwindow].endtime;
		index++;
	}  // 至此，完成k个客户的服务
	for (int i = 1; i <= q; i++) {
		int query, minute;
		scanf("%d", &query);
		minute = result[query];
		if (sorry[query] == true) printf("Sorry\n");
		else printf("%02d:%02d\n", minute / 60 + 8, minute % 60);
	}
	return 0;
}
```

**可以学习的**

1、队列的使用；pop()、push()、front()等函数的使用；

2、输出HH:MM的格式，使用printf较为简便；

3、用结构体将容器和常规变量组合在一起，用得好可以很强

### 1015 Reversible Primes

题目大意：给出规则如下，如果一个数本身是素数，而且在radix进制下反转后的树数在十进制下也是素数，就输出Yes，否则就输出No

解题思路：先判断输入n是否为素数，若是，把n转化为radix进制再反过来转换为10进制，判断其是否为素数

核心代码

```C++
bool isprime(int n) {
	if (n <= 1) return false;
	int sqr = int(sqrt(n * 1.0));
	for (int i = 2; i <= sqr; i++) if (n % i == 0) return false;
	return true;
}
int main() {
	int n, radix;
	while (scanf("%d", &n) != EOF) {  // 处理不给数据组数的输入
		if (n < 0) break;
		scanf("%d", &radix);
		if (isprime(n) == false) {
			printf("No\n");
			continue;
		}
		int len = 0, arr[100];
		do {  // 将数值逐位提取到数组中存储，下标小的是低位，长度为len
			arr[len++] = n % radix;
			n = n / radix;
		} while (n != 0);
		for (int i = 0; i < len; i++) 
			n = n * radix + arr[i];  // 将逐位存储的radix进制的数转化为十进制
		printf("%s", isprime(n) ? "Yes\n" : "No\n");
	}
	return 0;
}
```

**可以学习的**

1、素数判断函数，isprime的写法；

2、将数值逐位提取到数组中存储，以及将逐位存储的radix进制的数转化为十进制，的写法

### 1016 Phone Bills

题目大意：给出一天24小时每个小时的电话费价格，单位0.01$；再给出n行打电话的记录，包括人名、时间MM:dd:HH:mm、on-line/off-line；目的是打印出每个人的电话账单，包括人名、月份、电话开始时间、电话结束时间、持续时间、电话费用；输出时，按照人名字母序，再按时间先后顺序

解题思路：使用结构体存储每一行电话记录；将给出的数据先按照人名字母序排序，再按照时间的先后顺序排列，这样遍历时前后两个名字相同且状态依次为on-line、off-line的就是合格数据；排序后，声明map，将配对好的电话记录按照姓名转存到map中；按格式输出

```C++
struct node {
	string name;
	int month, day, hour, minute, status, time;  // time是换算到0:00:00的分钟数量，比大小用的
};
bool cmp1(node a, node b) return a.name != b.name ? a.name < b.name : a.time < b.time;
double billFromZero(node call, int* rate) {  // 从现在算到0:00:00的电话费用
	double total = rate[call.hour] * call.minute + rate[24] * 60 * call.day;
	for (int i = 0; i < call.hour; i++) total += rate[i] * 60;
	return total / 100.0;
}

int main() {
	int rate[25] = { 0 }, n;
	for (int i = 0; i < 24; i++) {
		cin >> rate[i];
		rate[24] += rate[i];  // 打一整天电话的费率
	}
	cin >> n;
	vector<node> data(n);  // n条call record
	for (int i = 0; i < n; i++) {
		cin >> data[i].name;
		scanf("%d:%d:%d:%d", &data[i].month, &data[i].day, &data[i].hour, &data[i].minute);
		string temp;
		cin >> temp;
		data[i].status = (temp == "on-line") ? 1 : 0;
		data[i].time = data[i].day * 24 * 60 + data[i].hour * 60 + data[i].minute;  // 以当月起点为基准，计算距基准的时间
	}  // 至此，输入完成
	// 将n个call record先按照姓名排序，再按照时间排序，这样遍历时前后两个名字相同且状态依次为1、0的就是合格数据
	sort(data.begin(), data.end(), cmp1);
	map<string, vector<node>> custom;
	for (int i = 1; i < n; i++) {
		if (data[i].name == data[i - 1].name && data[i - 1].status == 1 && data[i].status == 0) {  // 若配对成功
			custom[data[i - 1].name].push_back(data[i - 1]);
			custom[data[i].name].push_back(data[i]);  // 则将这一通电话的2个记录按照人名放到map中
		}
	}  // 至此，配对完成，可以进行输出了
	for (auto it : custom) {  // 遍历map
		vector<node> temp = it.second;  // 对一个人进行输出
		cout << it.first;
		printf(" %02d\n", temp[0].month);
		double total = 0.0;
		for (int i = 1; i < temp.size(); i += 2) {  // 一对一对输出
			double t = billFromZero(temp[i], rate) - billFromZero(temp[i - 1], rate);
			printf("%02d:%02d:%02d %02d:%02d:%02d %d $%.2lf\n", temp[i - 1].day, temp[i - 1].hour, temp[i - 1].minute, temp[i].day, temp[i].hour, temp[i].minute, temp[i].time - temp[i - 1].time, t);
			total += t;
		}
		printf("Total amount: $%.2lf\n", total);
	}
	return 0;
}
```

**可以学习的**

1、map的使用，遍历map的方法，用.first和.second访问map的元素

2、计算较为复杂的时间时，比如MM:dd:HH:mm，找一个基准点，比如当月1号，换算为其距基准的时间

3、结构体的使用，便利

### 1017 Queueing at Bank

题目大意：有n个人来银行，银行有k个窗口，给出每个人的到达时间和所需的服务时间，目的是求出所有人的平均等待时间；由于银行的工作时间是8:00到17:00，早于8:00得等，晚于17:00不提供服务也就不参与平均值的计算

解题思路：使用结构体存储客户到达的时间come和所需的服务时间time；输入时可以先把hh:mm:ss格式的时间转换为以当天0点为基准的秒数，且晚于17:00到的客户直接忽略掉；这里排队的机制决定了我们可以按照到达时间对客户进行排序，后面就客户就可以按照这个顺序去办理业务；使用一个长度为窗口长度的优先队列维护窗口办理完业务的时刻，若最早结束服务的窗口时间早于客户的到达时间，则下一位客户不需要等待，直接将这位客户办理完业务的时间入队列；若最早结束服务的窗口时间晚于客户的到达时间，则下一位客户需要等待，等待的时间是二者相减

核心代码

```C++
const int maxn = 10005;
struct node {
	int come, time;  // come是到银行的时间，time是所需的服务时间
} p[maxn];
int cmp(node n1, node n2) { return n1.come < n2.come;  // 先来的先服务 }
int n, k, cnt = 0, total = 0;
int main() {
	cin >> n >> k;
	for (int i = 0; i < n; i++) {
		int hh, mm, ss, tt;
		scanf("%02d:%02d:%02d %d", &hh, &mm, &ss, &tt);
		int sum = hh * 3600 + mm * 60 + ss;  // 将hh:mm:ss格式的时间转换为以当天0点为基准的秒数
		if (sum > 17 * 3600) continue;  // 晚于17:00来的人直接忽视
		p[++cnt].time = tt * 60;
		p[cnt].come = sum;
	}
	sort(p + 1, p + 1 + cnt, cmp);  // 按照到达的先后顺序排序
	priority_queue<int, vector<int>, greater<int>> q;  // 优先队列，升序
	for (int i = 1; i <= k; i++) q.push(8 * 3600);  // 初始化这个长度为窗口数量k的优先队列
	for (int i = 1; i <= cnt; i++) {
		if (q.top() <= p[i].come) {  // 不需要等
			q.push(p[i].come + p[i].time);  
			q.pop();
		} else {  // 等待一段时间
			total += q.top() - p[i].come;
			q.push(q.top() + p[i].time);
			q.pop();
		}
	}
	(!cnt) ? printf("0.0\n") : printf("%.1lf", (total / 60.0) / cnt);
	return 0;
}
```

**可以学习的**

1、优先队列的定义，三个参数，<类型，容器，顺序>，greater是升序

2、优先队列的用处，队列总是有序的

### 1018 Public Bike Management

题目大意：城市中的自行车站，最大容量为一个偶数$C_{max}$，定义车站里的自行车数量恰好为$C_{max}$ / 2时为完美状态；若一个车站不是完美状态，位于节点0处的调度中心就会携带或者在路上收集一定数量的自行车前往这个车站，以保证一路上所有车站都变为完美状态；现给出$C_{max}$、车站数量n、不完美车站$S_p$的数量及编号、m条边及每条边的长度；目的是求出最短路径(包括长度和具体路径)，如果有多条最短路径则输出所带去自行车数量最小的那条，若还有多条则求出所带回自行车数量最少的那条。

解题思路：Dijkstra + DFS；如果只有Dijkstra是不可以的，因为minNeed和minBack在路径上的传递不满足最优子结构，不是简单的相加的过程，只有在所有路径都确定了之后才能区选择最小的need和最小的back。那么，Dijkstra求最短路径，过程中将最短路径以邻接链表的形式存下来；dfs求minNeed、minBack和最终的path，总体思路是利用深度优先搜索先组装出一条条路径，然后求出这些条路径的need和back，再取最小值minNeed和minBack。

核心代码

```C++
const int inf = 99999999;
int cmax, n, sp, m;
int minNeed = inf, minBack = inf;
int e[510][510], dis[510], weight[510];
bool visit[510];  // 以上是写Dijkstra所需的基本变量
vector<int> pre[510], path, temppath;  // pre为邻接链表，显式地存放图的连接关系
void dfs(int v) {
	temppath.push_back(v);
	if (v == 0) {  // 从终点一直搜索到起点，到起点后才进入这个if
		int need = 0, back = 0;
		for (int i = temppath.size() - 1; i >= 0; i--) {  // 从起始点遍历到终点，去的路上就要使所有车站满足完美状态
			int id = temppath[i];
			if (weight[id] > 0) {  // 如果比完美状态大，就需要把多余的自行车带走
				back += weight[id];
			} else {
				if (back > (0 - weight[id])) {  // 如果有车站少自行车，且带回来的back能够满足
					back += weight[id];  // 则back吐出0 - weight[id]辆车，即back减小
				} else {  // 如果有车站少自行车，但带回来的back满足不了，
					need += ((0 - weight[id]) - back);  // back吐出来后还有的缺口只能由调度中心增加带出来的车辆，即need增加
					back = 0;  // 让back全吐出来，即置0
				}
			}
		}
		if (need < minNeed) {  // 先need最小
			minNeed = need;
			minBack = back;
			path = temppath;
		} else if (need == minNeed && back < minBack) {  // 若need已经最小，则再取back最小
			minBack = back;
			path = temppath;
		}
		temppath.pop_back();  // 这条路径完成，pop掉尾巴的一个元素，去找第二条路径
		return;
	}
	for (int i = 0; i < pre[v].size(); i++) {
		dfs(pre[v][i]);  // 从后往前深度搜索，只要节点之间先连接，就去搜索
	}
	temppath.pop_back();  // 搜索进去可能扑了个空，那就需要将刚进入函数的push_back给pop掉
	return;
}
int main() {
	fill(e[0], e[0] + 510 * 510, inf);
	fill(dis, dis + 510, inf);
	scanf("%d %d %d %d", &cmax, &n, &sp, &m);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &weight[i]);
		weight[i] = weight[i] - cmax / 2;  // 现在0是完美状态
	}
	for (int i = 0; i < m; i++) {
		int a, b, c;
		scanf("%d %d %d", &a, &b, &c);
		e[a][b] = e[b][a] = c;
	}  // 输入完成
	// 开始写Dijkstra算法
	dis[0] = 0;  // 这题节点0为起始点
	for (int i = 0; i <= n; i++) {
		int u = -1, minn = inf;
		for (int j = 0; j <= n; j++) {  // 每次取出未访问节点中距离最小的，记为u
			if (visit[j] == false && dis[j] < minn) {
				u = j;
				minn = dis[j];
			}
		}
		if (u == -1) break;
		visit[u] = true;
		for (int v = 0; v <= n; v++) {
			if (visit[v] == false && e[u][v] != inf) {
				if (dis[u] + e[u][v] < dis[v]) {
					dis[v] = dis[u] + e[u][v];  // 每次都有的最基本的更新
					pre[v].clear();
					pre[v].push_back(u);
				} else if (dis[u] + e[u][v] == dis[v]) {
					pre[v].push_back(u);  // 记下u到v的最短的所有路径
				}
			}
		}
	}
	dfs(sp);
	printf("%d 0", minNeed);
	for (int i = path.size() - 2; i >= 0; i--) printf("->%d", path[i]);
	printf(" %d", minBack);
	return 0;
}
```

**可以学习的**

1、Dijkstra的思想及其写法，这里主要是写法，思想在1003中也有说明

2、dfs的思想及其写法，需要特别注意用dfs组装最短路径时push()和pop()的位置

3、若题目的某个部分有二义性，在纸上模拟一遍未尝不是一种方法

### 1019 General Palindromic Number

题目大意：给出2个整数a和b，问十进制下的a在b进制下是否为回文数；若是，输出Yes，否输出No，并且输出a在b进制下的表示，以空格隔开

解题思路：先将a转化为b进制的形式，保存在数组里，比较数组左右两端是否对称

核心代码 与1015有段代码是一样的

```C++
int main() {
	int n, radix;
	scanf("%d %d", &n, &radix);
	int len = 0, arr[100];
	do {  // 将数值逐位提取到数组中存储，下标小的是低位，长度为len
		arr[len++] = n % radix;
		n = n / radix;
	} while (n != 0);
	int flag = 0;
	for (int i = 0; i < len / 2; i++) 
		if (arr[i] != arr[len - i - 1]) {
			printf("No\n");
			flag = 1;
			break;
		}
	if (!flag) printf("Yes\n");
	printf("%d", arr[len - 1]);
	for (int i = len - 2; i >= 0; i--) printf(" %d", arr[i]);
	return 0;
}
```

**可以学习的**

1、1015的2，将数值逐位提取到数组中存储，以及将逐位存储的radix进制的数转化为十进制，的写法

### 1020 Tree Traversals

题目大意：给定一棵二叉树的后序遍历和中序遍历，目的是输出其层序遍历的结果；题目假设数的键值是互不相等的正整数

解题思路：与已知后序中序转换为前序的思路相近，均不需要先构造二叉树再广度优先搜索；已知后序中序转换为前序，因为后序的最后一个总是根结点，令i在中序中找到该根结点，则i把中序分为两部分，左边是左子树，右边是右子树；因为是输出先序（根左右），所以先打印出当前根结点，然后打印左子树，再打印右子树。那么，在此前基础上，加一个变量index，表示当前的根结点在二叉树中所对应的下标（从0开始），所以进行一次输出先序的递归过程中，就可以把根结点下标index及所对应的值存储在map<int, int> level中，map是有序的，会根据index从小到大自动排序，这样递归完成后level中的值就是层序遍历的顺序；

核心代码

```C++
vector<int> post, in;
map<int, int> level;  // map是有序的，它自己会根据index从小到大排序
void pre(int root, int start, int end) {  // 已知后序和中序求前序的函数，root是对后续说的，start和end是对中序说的
	if (start > end) return;
	int i = start;
	while (i < end && in[i] != post[root]) i++;
	printf("%d ", post[root]);
	pre(root - (end - i) - 1, start, i - 1);  // post中的根节点下标减去右子树长度，再减去根的长度1，就是左子树长度，也是其根节点的下标
	pre(root - i, i + 1, end);
}

void pre2(int root, int start, int end, int index) {  // 已知后序和中序求层序的函数，基于pre修改而来
	if (start > end) return;
	int i = start;
	while (i < end && in[i] != post[root]) i++;
	level[index] = post[root];  // index表示当前节点在二叉树中所对应的下标
	pre2(root - (end - i) - 1, start, i - 1, 2 * index + 1);
	pre2(root - 1, i + 1, end, 2 * index + 2);
}
```

**可以学习的**

1、已知后序与中序输出前序，无需构造二叉树的写法

2、已知后序与中序输出层序，无需构造二叉树的写法

3、map是有序的，它自己会根据index从小到大排序

### 1021 Deepest Root

题目大意：给一个无向无环图，目的是找出其中的最长路，可以理解为求一棵树的直径

解题思路：首先dfs判断它有几个连通分量，若多个，则输出Error:x components，若只有一个，则说明给的是一棵树；那么，为了求这棵树的直径，做2遍dfs，第一遍任取起点dfs，用数组记录每个节点在dfs搜索中距起点的距离，其中有最大距离，记为Max，将所有距离为Max的节点存入集合set；第二遍从集合中任取一个元素，以此为起点dfs，重复第一次的操作；集合中元素是不重复的，按升序输出集合中的元素即可

核心代码

```C++
int n, maxheight = 0;
vector<vector<int>> v;
bool visit[10010];
set<int> s;
vector<int> temp;
void dfs(int node, int height) {
	if (height > maxheight) {  // 将高度(深度)最大的节点存进temp
		temp.clear();
		temp.push_back(node);
		maxheight = height;
	}
	else if (height == maxheight) {
		temp.push_back(node);
	}
	visit[node] = true;  // 这4行才是基础的dfs
	for (int i = 0; i < v[node].size(); i++)
		if (visit[v[node][i]] == false)
			dfs(v[node][i], height + 1);
}
int main() {
	scanf("%d", &n);
	v.resize(n + 1);
	int a, b, cnt = 0, s1 = 0;
	for (int i = 0; i < n - 1; i++) {
		scanf("%d %d", &a, &b);
		v[a].push_back(b);
		v[b].push_back(a);
	}  // 经典的对图的输入写法，这里的v选择了用多少开多少的写法
	for (int i = 1; i <= n; i++) {
		if (visit[i] == false) {
			dfs(i, 1);
			if (i == 1) {  // 找连通分量时的dfs被二次利用
				if (temp.size() != 0) s1 = temp[0];  // s1是从第一遍dfs后的最大距离节点中任取的一个，后面第二遍用
				for (int j = 0; j < temp.size(); j++) 
					s.insert(temp[j]);  // 一侧的最大距离节点已被找出，存储
			}
			cnt++;  // cnt代表强连通分量个数
		}
	}
	if (cnt >= 2) printf("Error: %d components", cnt);
	else {
		temp.clear();
		maxheight = 0;
		fill(visit, visit + 10010, false);
		dfs(s1, 1);  // 第二次dfs，从任选的s1节点出发，即可找到距离最长的所有节点
		for (int i = 0; i < temp.size(); i++)
			s.insert(temp[i]);  // 存入集合s，集合会自动去重和排序
		for (auto it = s.begin(); it != s.end(); it++)
			printf("%d\n", *it);
	}
	return 0;
}
```

**可以学习的**

1、集合set的性质及使用，set会自动去重和排序，且为升序

2、求树的直径的方法，仅需2次dfs

3、求连通分量个数的方法，dfs是一种，另一种并查集会更快，现在还不会

### 1022 Digital Library

题目大意：模拟数字图书馆的查询功能；给出n本书的信息（字符串内部有空格），以及m个查询请求，每个请求以数字编号打头，数字代表相应的查询命令，编号后是查询的搜索词；目的是输出这条查询请求、满足条件的书的id，若没有，则输出Not Found

解题思路：首先需要把书的信息存储起来；这道题比较特殊，只需要输出书的编号，那么建立除id外的其它信息与id的映射map<string, set\<id>>，是一个非常好的方式，即一本书的信息被拆分为多个信息存在不同的map中，形成一个分立的信息对应一个集合，集合里是符合该条件的书的id；由于输入的字符串内部有空格，得用getline(cin，string)；查询时，用map里的函数find；传参时，map一定要用引用传过去，否则编译器会将整个map拷贝过去，慢，而传引用只传一个地址，快。

核心代码

```C++
map<string, set<int>> title, author, key, pub, year;
void query(map<string, set<int>>& m, string& str) {
	if (m.find(str) != m.end())
		for (auto it = m[str].begin(); it != m[str].end(); it++)
			printf("%07d\n", *it);
	else 
		printf("Not Found\n");
}
int main() {
	int n, m, id, num;
	scanf("%d", &n);
	string ttitle, tauthor, tkey, tpub, tyear;
	for (int i = 0; i < n; i++) {
		scanf("%d\n", &id);
		getline(cin, ttitle);
		title[ttitle].insert(id);  // 将多个id放入集合，与要被查询的title映射
		getline(cin, tauthor);
		author[tauthor].insert(id);
		while (cin >> tkey) {
			key[tkey].insert(id);  // 关键词可以有多个，分开再与id映射
			char c = getchar();  // 可能读到空格或回车
			if (c == '\n') break;  // 若是空格，则继续
		}
		getline(cin, tpub);
		pub[tpub].insert(id);
		getline(cin, tyear);
		year[tyear].insert(id);
	}
	scanf("%d", &m);
	for (int i = 0; i < m; i++) {
		scanf("%d: ", &num);
		string temp;
		getline(cin, temp);
		cout << num << ": " << temp << endl;  // 这里不能用printf，string类型的temp会乱码
		if (num == 1) query(title, temp);
		else if (num == 2) query(author, temp);
		else if (num == 3) query(key, temp);
		else if (num == 4) query(pub, temp);
		else if (num == 5) query(year, temp);
	}
	return 0;
}
```

**可以学习的**

1、内部有空格的字符串得用getline输入，getline(cin, string)

2、当输入一行不知道个数的以空格隔开的字符串时，用while(cin>>s) c = getchar; 判断c是否为换行\n

3、printf是C的函数，不能直接输出C++才有的string数据类型，换cout就行

4、空间换时间，妙用STL的组合，这里指map<string, set\<int>>

### 1023 Have Fun with Numbers

题目大意：给出一个长度不超过20的整数，问这个整数乘以2后，是否为原来数位的一个排列，是不是还是那些数字；是则输出Yes，否则No，以及乘以2后的那个数

解题思路：~~用python写很方便~~ 使用char数组存储这个数，每个数位乘以2并进位；设立book来标记数位出现的次数

核心代码

```C++
int book[10]; // 记录每个数字的个数
int main() {
	char num[22];
	scanf("%s", num);
	int flag = 0, len = strlen(num);  // 轻松读入char数组并且获取其长度
	for (int i = len - 1; i >= 0; i--) {  // 从个位开始
		int temp = num[i] - '0';  // 取出一个数位
		book[temp]++;  // 该数位加1
		temp = temp * 2 + flag;  // flag是进位与否的标志
		flag = 0;
		if (temp >= 10) {
			temp = temp - 10;
			flag = 1;
		}
		num[i] = temp + '0';  // 乘以2后的数位
		book[temp]--;  // 乘以2后的数位减1
	}
	int flag1 = 0;
	for (int i = 0; i < 10; i++) 
		if (book[i] != 0) {
			flag1 = 1;
			break;
		}
	printf("%s", (flag == 1 || flag1 == 1) ? "No\n" : "Yes\n");
	if (flag == 1) printf("1");  // 最高位进位了的情况
	printf("%s", num);
	return 0;
}
```

**可以学习的**

1、大数乘以2的写法，涉及进位的过程

2、获取输入的char数组的长度，用strlen()函数，在cstring头文件中

### 1024 Palindromic Number

题目大意：给一个整数n和允许操作的次数cnt，定义一次操作为：将n反转再与自己相加；目的是求出需要多少次操作能变为一个回文数，若不能在cnt次内完成，则输出在第cnt次时的结果

解题思路：~~用python写很方便~~ 用字符串s存储这个整数，因为此题中容易溢出long；实现大整数相加；

核心代码

```C++
string add(string s, string t) {  // 大整数加法函数， s = s + t
	int len = s.length(), carry = 0;
	for (int i = len - 1; i >= 0; i--) {  // 从个位开始
		s[i] = s[i] + t[i] + carry - '0';
		carry = 0;
		if (s[i] > '9') {
			s[i] = s[i] - 10;
			carry = 1;  // 有进位，由于是加法，最多进1
		}
	}
	if (carry) s = '1' + s;  // 若最高位有进位，则再添个1
	return s;
}
```

**可以学习的**

1、大整数加法

### 1025 PAT Ranking

题目大意：有n个考场，每个考场有k个学生，给出每个学生的编号和分数；目的是求出一张排名表，包含编号、总排名、考场号、考场内排名

解题思路：用结构体存储每个学生的编号、分数、总排名、考场号、考场内排名；先按考场内排名，存储；然后赋值给总的数组fin，再进行总排名；输出。排名思路与1012相近

核心代码

```C++
struct student {
	long long int id;
	int score, finrank, loca, locarank;
};
bool cmp1(student a, student b) {
	return a.score != b.score ? a.score > b.score : a.id < b.id;
}
int main() {
	int n, m;
	cin >> n;
	vector<student> fin;
	for (int i = 0; i < n; i++) {
		cin >> m;
		vector<student> v(m);
		for (int j = 0; j < m; j++) {
			scanf("%lld %d", &v[j].id, &v[j].score);
			v[j].loca = i + 1;  // 为考场号赋值
		}
		sort(v.begin(), v.end(), cmp1);  // 先按考场内排名
		v[0].locarank = 1;
		fin.push_back(v[0]);
		for (int j = 1; j < m; j++) {
			v[j].locarank = (v[j].score == v[j - 1].score) ? (v[j - 1].locarank) : (j + 1);  // 把排名存入结构体
			fin.push_back(v[j]);  // 赋值给总的数组
		}
	}
	sort(fin.begin(), fin.end(), cmp1);  // 再进行总排名
	fin[0].finrank = 1;
	for (int j = 1; j < fin.size(); j++) {
		fin[j].finrank = (fin[j].score == fin[j - 1].score) ? (fin[j - 1].finrank) : (j + 1);  // 把总排名存入结构体
	}
	printf("%d\n", fin.size());  // 开始输出
	for (int i = 0; i < fin.size(); i++) 
		printf("%013lld %d %d %d\n", fin[i].id, fin[i].finrank, fin[i].loca, fin[i].locarank);
	return 0;
}
```

**可以学习的**

1、排名问题的通用写法，定义结构体，sort，遍历赋值排名

